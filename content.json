{"meta":{"title":"爱编程-爱挑战-爱学习","subtitle":null,"description":"程序员就是我,我就是程序元","author":"TWei","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-10-10T08:40:58.000Z","updated":"2019-10-10T08:41:21.127Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-10T08:40:06.000Z","updated":"2019-10-10T08:40:46.724Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"三种隐藏元素方法的区别","slug":"三种隐藏元素方法的区别","date":"2019-10-15T08:47:42.000Z","updated":"2019-10-15T08:49:35.557Z","comments":true,"path":"2019/10/15/三种隐藏元素方法的区别/","link":"","permalink":"http://yoursite.com/2019/10/15/三种隐藏元素方法的区别/","excerpt":"display:none 元素在页面上将消失,不占据页面空间,会导致浏览器的回流与重绘,不能响应交互类事件；","text":"display:none 元素在页面上将消失,不占据页面空间,会导致浏览器的回流与重绘,不能响应交互类事件； visibility:hidden 元素在页面占据的空间不变,所以它只会导致浏览器重绘而不会回流,也不能响应交互类事件； opacity:0 元素在页面占据的空间不变，不会导致浏览器回流或重绘（因为浏览器对于transform和opacity这两种变化处理的方法为合成渲染,可以响应交互类事件。","categories":[],"tags":[]},{"title":"02CSS浮动","slug":"02CSS浮动","date":"2019-10-15T08:47:22.000Z","updated":"2019-10-15T08:49:00.635Z","comments":true,"path":"2019/10/15/02CSS浮动/","link":"","permalink":"http://yoursite.com/2019/10/15/02CSS浮动/","excerpt":"一.CSS浮动是什么?css浮动就是浮动元素会脱离文档的普通流,根据float的值向左或向右移动,直到它的外边界碰到父元素的内边界或另一个浮动元素的外边界为止 1.相关概念 标准文档流:普通流/文档流 脱标:脱离标准流 CSS中一共有三种脱标手段:","text":"一.CSS浮动是什么?css浮动就是浮动元素会脱离文档的普通流,根据float的值向左或向右移动,直到它的外边界碰到父元素的内边界或另一个浮动元素的外边界为止 1.相关概念 标准文档流:普通流/文档流 脱标:脱离标准流 CSS中一共有三种脱标手段: 浮动 绝对定位 固定定位 网页布局的三种流 文档流 浮动流 定位流 二.浮动1.浮动API语法： float : none | left | right none:元素不浮动 left:元素向左浮动 right:元素向右浮动 2.浮动规则 浮动元素位于文档流之上,会遮挡文档流 如果同为浮动元素,会从左向右/从右向左,自上而下依次排列,会被高度高的浮动元素卡住 如果上一个元素为文档流中的元素,浮动元素的相对垂直位置不变,与文档流元素底部对齐(浮动元素不会超过它前边未进行浮动元素的底部) 浮动流只有一种排版方式,就是水平排版,它只能设置某个元素左对齐或者右对齐,在浮动流中是不可以使用margin: 0 auto; 如果同一行中左右浮动都存在,位置不够时,右浮动元素的后边元素会向下排列,左浮动先会保持不变,只有当宽度容不下左浮动元素的宽度,左浮动元素才会向下移动 3.浮动特性 元素浮动以后变成行内块元素 元素浮动以后后边如果是行内元素或者行内-块级元素(两者视为文本),浮动元素不会遮挡文本 元素浮动以后后边如果块级元素(里面包含文本)/块级元素内部包含行内元素或者行内-块级元素,浮动元素不会遮挡文本 三.清除浮动1.清除浮动API语法： clear : none | left | right | both none:允许两边有浮动元素 left:不允许左边有浮动元素 right:不允许右边有浮动元素 both:不允许两边有浮动元素(左边|右边|两边) 2.清除浮动规则 只能作用于块级元素或浮动元素 浮动只能影响调用它的元素 清除浮动不能作用域行内/行内-块级元素,因为浮动元素不会遮挡行内/行内-块级元素","categories":[],"tags":[]},{"title":"01标准文档流","slug":"01标准文档流","date":"2019-10-15T08:47:05.000Z","updated":"2019-10-15T08:48:20.546Z","comments":true,"path":"2019/10/15/01标准文档流/","link":"","permalink":"http://yoursite.com/2019/10/15/01标准文档流/","excerpt":"HTML元素分类 块级元素 独占一行,自上向下排列 默认宽度为父元素的100% 默认高度被内容撑开 可设置高/宽/内边距/外边距","text":"HTML元素分类 块级元素 独占一行,自上向下排列 默认宽度为父元素的100% 默认高度被内容撑开 可设置高/宽/内边距/外边距 行内元素 和其他非块级元素在同一行 只占自身大小,从左到右,自上向下排列 宽度和高度被内容撑开 不可设置高/宽/上下内边距/上下外边距 行内-块级元素即置换元素 和其他非块级元素在同一行 从左到右,自上向下排列 可设置高/宽/内边距/外边距 注意事项 行内元素:设置上下内边距,显示效果是增加了,只不过是表象,设置是无效的,对周围元素无任何影响,但设置背景会覆盖周围元素 行内块级元素:设置行高会影响同行相同元素类型的行高,与其保持一致 行内元素/行内-块级元素:进行页面布局的时候会把空的文本节点计算在内 置换元素:是指浏览器根据元素的标签和属性，来决定元素的具体显示内容,可以设置高宽/内外边距,性质同设置了display:inline-block的元素一致。而img元素虽然是行内元素 但它也是置换元素 html中的都是置换元素，这些置换元素往往没有实际内容，即是一个空元素。 例如：浏览器根据img标签的src属性显示图片。根据input标签的type属性决定显示输入框还是按钮 非置换元素:浏览器中的大多数元素都是不可置换元素，即其内容直接展示给浏览器 h1~h6/p/dt元素:只能包含行内元素，不能再包含块级元素 块级元素和行内元素的嵌套规范(规则) 行内元素可以嵌套行内元素,不可以嵌套块级元素 块级元素,可以嵌套块级元素,或者是行内元素 部分块级元素,不能嵌套块级元素,只能嵌套行内元素,如:p、h1-h6、dt(p是真正的不能,其余的是规范的问题) 块级元素中嵌套的元素,块级元素和块级元素一级,行内元素和行内元素一级 HTML元素转换API语法： display : none | block | inline | inline-block none:此元素不会被显示(隐藏渲染) block:此元素将显示为块级元素 inline:此元素将显示为行内元素 inline-block:此元素将显示为行内-块级元素","categories":[],"tags":[]},{"title":"Vue之深入响应式原理","slug":"Vue之深入响应式原理","date":"2019-10-13T02:41:02.000Z","updated":"2019-10-13T02:46:10.014Z","comments":true,"path":"2019/10/13/Vue之深入响应式原理/","link":"","permalink":"http://yoursite.com/2019/10/13/Vue之深入响应式原理/","excerpt":"理解Vue响应式原理,只需通过解决以下几个问题即可 如何实现数据劫持? 如何实现数据代理?(如何对this.xxx的访问代理到this.data.xxx上?) 如何实现数据编译? 如何实现发布订阅模式? 如何实现更新视图?(如何监听数据的读写操作?如何实现数据修改DOM更新?) 如何实现双向数据绑定? 如何实现依赖缓存? template改变的时候,如何清理依赖项集合?eg:v-if和组件销毁","text":"理解Vue响应式原理,只需通过解决以下几个问题即可 如何实现数据劫持? 如何实现数据代理?(如何对this.xxx的访问代理到this.data.xxx上?) 如何实现数据编译? 如何实现发布订阅模式? 如何实现更新视图?(如何监听数据的读写操作?如何实现数据修改DOM更新?) 如何实现双向数据绑定? 如何实现依赖缓存? template改变的时候,如何清理依赖项集合?eg:v-if和组件销毁 前提1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; a.a &#125;&#125;&lt;/p&gt; &lt;span&gt;&#123;&#123; b &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;const vm = new Mvvm(&#123; el: &apos;#app&apos;, data: &#123; a: &#123; a: &apos;我是a&apos; &#125;, b: &apos;我是b&apos; &#125; &#125;)&lt;/script&gt; 问题:如何实现数据劫持答:通过Object.defineProperty()方法,对data中的属性,在访问或者修改对象的其中某个属性时,通过一段代码拦截这个行为,进行额外的操作或者修改返回结果 12345678910111213141516171819202122232425262728293031323334353637// TODO:1.定义Mvvm类function Mvvm(options=&#123;&#125;)&#123; // TODO:this代表的是fade实例对象 // TODO:将所有属性挂载到$options this.$options = options var data = this._data = this.options.data // TODO:调用数据劫持 observe(data)&#125;// TODO:3.观察者function Observe(obj)&#123; for (let key in obj) &#123; let val = obj[key] // TODO:深度劫持 observe(val) Object.defineProperty(obj,key,&#123; enumerable : true, get()&#123; return val &#125;, set(newVal)&#123; if (newVal === val) return val = newVal // TODO:深度劫持 observe(newVal) &#125; &#125;) &#125;&#125;// TODO:2.数据劫持-使每个对象都具有get和set方法function observe(vmData)&#123; if (typeof data !== &apos;object&apos;) return return new Observe(vmData)&#125; 问题:如何实现数据代理-如何对this.xxx的访问代理到this.data.xxx上?答:对于每个data上的属性,都在app上做一个代理,实际操作的是this.data实现的代码如下: 1234567891011121314151617181920function Mvvm(options = &#123;&#125;) &#123; // TODO:this代表的是zhufeng实例对象 // TODO:将所有属性挂载到$options this.$options = options //this._data var data = this._data = this.$options.data observe(data) // TODO:4.数据代理 for (let key in data) &#123; Object.defineProperty(this,key,&#123; enumerable : true, get()&#123; return this._data[key] &#125;, set(newVal)&#123; this._data[key] = newVal &#125; &#125;) &#125;&#125; 问题:如何实现数据编译答:通过获取vm管理DOM的根节点,让其在内存中完成相关的正则匹配工作,替换DOM中的文本节点 123456789101112131415161718192021222324252627282930// TODO:5数据编译function Compile(el,vm)&#123; vm.$el = document.querySelector(el) let fragment = document.createDocumentFragment() while (child = vm.$el.firstChild) &#123; fragment.appendChild(child) &#125; replace(fragment) // TODO:6.数据替换 function replace(frag)&#123; Array.from(frag.childNodes).forEach(function (node) &#123; let text = node.textContent let regExp = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/ if (node.nodeType === 1 &amp;&amp; regExp.test(text)) &#123; let arr = RegExp.$1.trim().split(&apos;.&apos;) let val = vm arr.forEach(function (k) &#123; val = val[k] &#125;) node.textContent = text.replace(regExp,val).trim() &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; replace(node) &#125; &#125;) &#125; vm.$el.appendChild(fragment)&#125; 12345function Mvvm(options = &#123;&#125;) &#123; .... // TODO:进行编译 new Compile(optionns.el,this)&#125; 问题:如何实现发布订阅模式答:发布订阅主要靠的就是数组关系，订阅就是放入函数，发布就是让数组里的函数执行 12345678910111213141516171819202122// TODO:8.发布订阅模式// TODO:桥梁function Dep()&#123; // 桥梁 this.subs = [] // 订阅事件池&#125;// TODO:进行订阅的方法(往里面扔函数)Dep.property.addSub = function (sub) &#123; //sub就是watcher this.subs.push(sub)&#125;// TODO:进行发布/通知的方法(让函数的每一项一次执行)Dep.prototype.notify = function () &#123; this.subs.forEach(sub =&gt; sub.update())//绑定的事件,都有一个update属性&#125;// TODO:订阅者function Watcher(fn)&#123; //Watcher是一个类,通过这个类创建的实例都拥有update方法 this.fn = fn&#125;Watcher.prototype.update = function () &#123; //调用fn() this.fn()&#125; 问题:如何更新视图-当数据改变需要重新刷新视图答:现在我们要订阅一个事件，当数据改变需要重新刷新视图，这就需要在replace替换的逻辑里来处理通过new Watcher把数据订阅一下，数据一变就执行改变内容的操作 监听变化 123456789101112131415// TODO:6.数据替换 function replace(frag) &#123; ... node.textContent = text.replace(regExp, val).trim() // TODO:监听变化 new Watcher(vm,RegExp.$1,function (newVal) &#123; node.textContent = text.replace(regExp,newVal).trim() &#125;) if (node.childNodes &amp;&amp; node.childNodes.length) &#123; replace(node) &#125; ... &#125; 重写Watcher构造函数 1234567891011121314// TODO:订阅者function Watcher(vm,exp,fn)&#123; //Watcher是一个类,通过这个类创建的实例都拥有update方法 this.fn = fn this.vm = vm this.exp = exp Dep.target = this let arr = exp.trim().split(&apos;.&apos;) let val = vm arr.forEach(function (key) &#123; val = val[key] &#125;) Dep.target = null // // 上面获取val[key]的时候会调用get方法, 因此使用完毕之后需要把该属性置为null&#125; 重写数据劫持get和set方法 解:当获取值的时候就会自动调用get方法，于是我们去找一下数据劫持那里的get方法123456789101112131415161718192021222324252627// TODO:3.观察者function Observe(obj)&#123; // TODO:创建桥梁 let dep = new Dep() for (let key in obj) &#123; let val = obj[key] // TODO:深度劫持 observe(val) Object.defineProperty(obj,key,&#123; enumerable : true, get()&#123; // TODO:将watcher添加到订阅事件中 [watcher] Dep.target &amp;&amp; dep.addSub(Dep.target) return val &#125;, set(newVal)&#123; // 更改值得时候 if (newVal === val) return // 设置的值和以前的是一样的东西 val = newVal // 如果以后在获取值的时候将刚才设置的值丢回去 // TODO:深度劫持 observe(newVal) // TODO:执行update方法 dep.notify() &#125; &#125;) &#125;&#125; 修改watcher的update方法 解:当set修改值的时候执行了dep.notify方法，这个方法是执行watcher的update方法，那么我们再对update进行修改一下1234567891011Watcher.prototype.update = function () &#123; //调用fn() this.fn() // notify的时候值已经更改了 // 再通过vm, exp来获取新的值 let arr = this.exp.trim().split(&apos;.&apos;) let val = this.vm arr.forEach(function(key)&#123; val = val[key] &#125;) this.fn(val) // 将每次拿到的新值去替换&#123;&#123;&#125;&#125;的内容即可&#125; 问题:双向数据绑定","categories":[],"tags":[]},{"title":"标准网页标签模板及其每个标签的作用","slug":"标准网页标签模板及其每个标签的作用","date":"2019-10-12T15:06:27.000Z","updated":"2019-10-13T02:45:49.820Z","comments":true,"path":"2019/10/12/标准网页标签模板及其每个标签的作用/","link":"","permalink":"http://yoursite.com/2019/10/12/标准网页标签模板及其每个标签的作用/","excerpt":"","text":"123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt; + 声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。 + 通过document.compatMode查看模式： + BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。 + CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。 &lt;html lang=&quot;en/zh-CN&quot;&gt; + lang=&quot;en&quot; 向搜索引擎表示该页面是html语言，并且语言为英文网站,并提示浏览器是否进行翻译 + lang=&quot;zh-CN&quot; 向搜索引擎表示该页面是html语言，并且语言为中文网站&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;/&gt; + 声明文档使用的字符编码&lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;&gt; + 移动端布局&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; + 告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面或告诉浏览器用chrome内核来渲染&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;/&gt; + 指定双核浏览器默认以何种方式渲染页面&lt;title&gt;&lt;/title&gt; + 标题&lt;meta name=&quot;description&quot; content=&quot;#[[$description$]]#&quot;/&gt; + 描述&lt;meta name=&quot;keyword&quot; content=&quot;#[[$keyword$]]#&quot;/&gt; + 关键字&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/body&gt;","categories":[],"tags":[]},{"title":"前端高度塌陷问题","slug":"前端高度塌陷问题","date":"2019-10-12T07:22:43.000Z","updated":"2019-10-13T02:36:48.264Z","comments":true,"path":"2019/10/12/前端高度塌陷问题/","link":"","permalink":"http://yoursite.com/2019/10/12/前端高度塌陷问题/","excerpt":"一.产生原因 在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。","text":"一.产生原因 在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。 二.所以在开发中一定要避免出现高度塌陷的问题, 1.我们可以将父元素的高度写死，以避免塌陷的问题出现， 但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。 2.根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。 (1)当开启元素的BFC以后，元素将会具有如下的特性： 父元素的垂直外边距不会和子元素重叠 开启BFC的元素不会被浮动元素所覆盖 开启BFC的元素可以包含浮动的子元素 (2)如何开启元素的BFC 设置元素浮动 1使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失而且使用这种方式也会导致下边的元素上移，不能解决问题 设置元素绝对定位 设置元素为inline-block 1可以解决问题，但是会导致宽度丢失，不推荐使用这种方式 将元素的overflow设置为一个非visible的值 123456推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式,但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题开启方式很多，我们直接使用一种副作用最小的： 直接将元素的zoom设置为1即可 zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍 zoom:1表示不放大元素，但是通过该样式可以开启hasLayout zoom这个样式，只在IE中支持，其他浏览器都不支持 最终兼容方案 1234.clearfix&#123; overflow: hidden; zoom:1;&#125; 3.通过在高度塌陷的父元素的最后，添加一个空白的div,然后在对其进行清除浮动,但会在页面中添加多余结构 由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后在对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用,使用这种方式虽然可以解决问题，但是会在页面中添加多余的结构。 最终方案123.clearfix&#123; clear: both;&#125; 4.通过after伪类在高度塌陷的父元素的最后,添加一个空白的块元素，然后对其清除浮动，不会再页面中添加多余结构 这样做和添加一个div的原理一样，可以达到一个相同的效果，而且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用 12345678 .clearfix:after&#123; // 添加一个内容 content: &quot;&quot;; // 转换为一个块元素 display: block; // 清除两侧的浮动 clear: both;&#125; 在IE6中不支持after伪类,所以在IE6中还需要使用hasLayout来处理12345678.clearfix&#123; zoom:1;&#125;.clearfix:after&#123; content: &quot;&quot;; display: block; clear: both;&#125; 5.子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素,使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠 解决父子元素的外边距重叠 1234.box1:before&#123; content: &quot;&quot;; display:table可以将一个元素设置为表格显示&#125; 解决父元素高度塌陷 12345678.clearfix&#123; zoom:1;&#125;.clearfix:after&#123; content: &quot;&quot;; display: block; clear: both;&#125; 经过修改后的clearfix是一个多功能的既可以解决高度塌陷，又可以确保父元素和子元素的垂直外边距不会重叠 123456789.clearfix&#123; zoom: 1;&#125;.clearfix:before,.clearfix:after&#123; content: &quot;&quot;; display: table; clear: both;&#125;","categories":[],"tags":[]},{"title":"了解Object.defineProperty()方法","slug":"了解Object-defineProperty-方法","date":"2019-10-10T15:44:19.000Z","updated":"2019-10-13T02:38:58.469Z","comments":true,"path":"2019/10/10/了解Object-defineProperty-方法/","link":"","permalink":"http://yoursite.com/2019/10/10/了解Object-defineProperty-方法/","excerpt":"Object.defineProperty(obj,prop,descriptor)1.参数 obj 要在其上定义属性的对象。 prop 要定义或修改的属性的名称。 descriptor 将被定义或修改的属性描述符。 2.返回值 被传递给函数的对象obj","text":"Object.defineProperty(obj,prop,descriptor)1.参数 obj 要在其上定义属性的对象。 prop 要定义或修改的属性的名称。 descriptor 将被定义或修改的属性描述符。 2.返回值 被传递给函数的对象obj 3.属性描述符 configurable // 可删除 enumerable // 可枚举 writable // 可赋值 value get // 访问 set // 修改 注意: value和writable与get和set不能共存 obj.prop 调用get方法 obj.prop = ‘xxx’ 调用set方法","categories":[],"tags":[]},{"title":"NVM_Node_NPM_CNPM安装","slug":"NVM-Node-NPM-CNPM安装","date":"2019-10-10T05:36:11.000Z","updated":"2019-10-10T12:32:30.867Z","comments":true,"path":"2019/10/10/NVM-Node-NPM-CNPM安装/","link":"","permalink":"http://yoursite.com/2019/10/10/NVM-Node-NPM-CNPM安装/","excerpt":"NVM-windows安装第一步:下载NVM安装包:https://github.com/coreybutler/nvm-windows/releases第二步:创建俩个文件目录,解压安装包到NVM目录中:D:\\NVMD:\\Node","text":"NVM-windows安装第一步:下载NVM安装包:https://github.com/coreybutler/nvm-windows/releases第二步:创建俩个文件目录,解压安装包到NVM目录中:D:\\NVMD:\\Node 第三步:进入NVM目录双击 install.cmd 直接回车第四步:修改setting.txt文件复制到D:\\NVM目录中root: D:\\NVMpath: D:\\Nodearch: 64proxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/第五步:配置环境变量NVM_HOME和NVM_SYMLINKNVM_HOME : D:\\NVMNVM_SYMLINK : D:\\Node第六步:path中添加变量%NVM_HOME%%NVM_SYMLINK%第七步:查看NVM版本信息nvm -vNode-windows安装第一步:安装Node(为了后续安装全局npm准备)nvm install 6.15.0第二步:使用Nodenvm use 6.15.0第三步:在nvm\\node_dir下创建node_cache和node_global文件加第四步配置缓冲路径和全局路径(使C:\\Users\\yi081.npmrc 】文件重新生成)npm config set prefix “D:\\NVM\\node_dir\\node_global”npm config set cache “D:\\NVM\\node_dir\\node_cache”第五步:配置Node环境变量NODE_HOME和NODE_PATHNODE_HOME:D:\\Node\\node_modulesNODE_GLOBAL:D:\\NVM\\node_dir\\node_global (可不配置)NODE_PATH : D:\\NVM\\node_dir\\node_global\\node_modules第六步:添加到path中%NODE_HOME%%NODE_GLOBAL% (可不配置)%NODE_PATH%全局安装NPM第一步:下载npmnpm install npm@latest -g第二步:配置NPM环境变量NPM_HOME : D:\\NVM\\node_dir\\node_global\\npm第三步:添加到path中%NPM_HOME%全局安装CNPM第一步:下载cnpmnpm install -g cnpm –registry=https://registry.npm.taobao.org第二步:配置CNPM环境变量(可不配置)CNPM_HOME : D:\\NVM\\node_dir\\node_global\\cnpm第三步:添加到path中(可不配置)%NPM_HOME%","categories":[],"tags":[]}]}