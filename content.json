{"meta":{"title":"爱编程-爱挑战-爱学习","subtitle":null,"description":"程序员就是我,我就是程序元","author":"TWei","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-10-10T08:40:58.000Z","updated":"2019-10-10T08:41:21.127Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-10T08:40:06.000Z","updated":"2019-10-10T08:40:46.724Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端高度塌陷问题","slug":"前端高度塌陷问题","date":"2019-10-12T07:22:43.000Z","updated":"2019-10-12T07:23:45.350Z","comments":true,"path":"2019/10/12/前端高度塌陷问题/","link":"","permalink":"http://yoursite.com/2019/10/12/前端高度塌陷问题/","excerpt":"* *一.在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。 -但是当为子元素设置浮动以后，子元素会完全脱离文档流， -此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。 -由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。 二.所以在开发中一定要避免出现高度塌陷的问题,","text":"* *一.在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。 -但是当为子元素设置浮动以后，子元素会完全脱离文档流， -此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。 -由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。 二.所以在开发中一定要避免出现高度塌陷的问题, 1.我们可以将父元素的高度写死，以避免塌陷的问题出现， -但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。 2.根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context -简称BFC，该属性可以设置打开或者关闭，默认是关闭的。 (1)当开启元素的BFC以后，元素将会具有如下的特性： 1.父元素的垂直外边距不会和子元素重叠 2.开启BFC的元素不会被浮动元素所覆盖 3.开启BFC的元素可以包含浮动的子元素 (2)如何开启元素的BFC 1.设置元素浮动 使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失 而且使用这种方式也会导致下边的元素上移，不能解决问题 2.设置元素绝对定位 3.设置元素为inline-block 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式 4.将元素的overflow设置为一个非visible的值 推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式 -但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。 在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout， 属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题 开启方式很多，我们直接使用一种副作用最小的： -直接将元素的zoom设置为1即可 zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍 zoom:1表示不放大元素，但是通过该样式可以开启hasLayout zoom这个样式，只在IE中支持，其他浏览器都不支持 zoom:1; overflow: hidden; 3.可以直接在高度塌陷的父元素的最后，添加一个空白的div， 由于这个div并没有浮动，所以他是可以撑开父元素的高度的， 然后在对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度， 基本没有副作用 使用这种方式虽然可以解决问题，但是会在页面中添加多余的结构。 .clear{ clear: both; } 4.通过after伪类，选中box1的后边 可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动， 这样做和添加一个div的原理一样，可以达到一个相同的效果， 而且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用 .clearfix:after{ //添加一个内容 content: “”; //转换为一个块元素 display: block; //清除两侧的浮动 clear: both; } 在IE6中不支持after伪类,所以在IE6中还需要使用hasLayout来处理 .clearfix{ zoom:1; } .clearfix:after{ content: “”; display: block; clear: both; } .clearfix{ zoom:1; } 5.子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素 使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠 -解决父子元素的外边距重叠 .box1:before{ content: “”; display:table可以将一个元素设置为表格显示 } -解决父元素高度塌陷 .clearfix:after{ content: “”; display: block; clear: both; } 经过修改后的clearfix是一个多功能的 既可以解决高度塌陷，又可以确保父元素和子元素的垂直外边距不会重叠 .clearfix:before, .clearfix:after{ content: “”; display: table; clear: both; } .clearfix{ zoom: 1; }","categories":[],"tags":[]},{"title":"Vue深入响应式原理","slug":"Vue深入响应式原理","date":"2019-10-10T15:46:17.000Z","updated":"2019-10-10T15:52:07.831Z","comments":true,"path":"2019/10/10/Vue深入响应式原理/","link":"","permalink":"http://yoursite.com/2019/10/10/Vue深入响应式原理/","excerpt":"理解Vue响应式原理,只需通过解决以下几个问题即可 如何对this.xxx的访问代理到this.data.xxx上? 如何实现数据劫持,监听数据的读写操作? 如何实现依赖缓存? template改变的时候,如何清理依赖想集合?eg:v-if和组件销毁 如何实现数据修改DOM更新","text":"理解Vue响应式原理,只需通过解决以下几个问题即可 如何对this.xxx的访问代理到this.data.xxx上? 如何实现数据劫持,监听数据的读写操作? 如何实现依赖缓存? template改变的时候,如何清理依赖想集合?eg:v-if和组件销毁 如何实现数据修改DOM更新 前提123456789&lt;div id=&quot;app&quot;&gt; &#123;&#123; a &#125;&#125;&lt;/div&gt;&lt;script&gt;let fade = Fade(&#123; el:&quot;#app&quot;, data:&#123;a:&#123; a:1&#125;&#125;&#125;)&lt;/script&gt; 问题:如何实现数据劫持答:通过Object.defineProperty对data上的key进行操作 12345678910111213141516171819202122232425262728293031323334function Fade(options=&#123;&#125;)&#123; // TODO:this代表的是fade实例对象 // TODO:将所有属性挂载到$options this.$options = options var data = this._data = this.options.data observe(data)&#125;function Observe(data)&#123; for(let key in data)&#123; let val = data[key] observe(val) // TODO:把data属性通过objecet.defineProperty的方式定义属性 Object.defineProperty(data,key,&#123; enumerable : true, get()&#123; return val &#125;, set(newVal)&#123;// TODO:更改值得时候 // TODO:设置的值和以前的是一样的东西 if(newVal === val)&#123; return &#125; // TODO:如果以后在获取值的时候将刚才设置的值丢回去 val = newVal observe(newVal) &#125; &#125;) &#125;&#125;function observe(data)&#123; return new Observe(data)&#125; 问题:如何对this.xxx的访问代理到this.data.xxx上?答:对于每个data上的key,都在app上做一个代理,实际操作的是this.data实现的代码如下: 1234567891011121314151617181920function Fade(options = &#123;&#125;) &#123; // TODO:this代表的是zhufeng实例对象 // TODO:将所有属性挂载到$options this.$options = options //this._data var data = this._data = this.$options.data observe(data) // TODO:this代理了this._data for (let key in data) &#123; Object.defineProperty(this, key, &#123; enumerable: true, get() &#123; return this._data[key] //this.a = &#123;a : 1&#125; &#125;, set(newVal) &#123; this._data[key] = newVal &#125; &#125;) &#125;&#125;","categories":[],"tags":[]},{"title":"了解Object.defineProperty()方法","slug":"了解Object-defineProperty-方法","date":"2019-10-10T15:44:19.000Z","updated":"2019-10-10T15:45:17.733Z","comments":true,"path":"2019/10/10/了解Object-defineProperty-方法/","link":"","permalink":"http://yoursite.com/2019/10/10/了解Object-defineProperty-方法/","excerpt":"Object.defineProperty(obj,prop,descriptor)1.参数 obj 要在其上定义属性的对象。 prop 要定义或修改的属性的名称。 descriptor 将被定义或修改的属性描述符。 2.返回值 被传递给函数的对象obj","text":"Object.defineProperty(obj,prop,descriptor)1.参数 obj 要在其上定义属性的对象。 prop 要定义或修改的属性的名称。 descriptor 将被定义或修改的属性描述符。 2.返回值 被传递给函数的对象obj 3.属性描述符 configurable //抗飞个弱儿包 可删除 enumerable //硬牛么儿包 可枚举 writable //ruai特儿包 可赋值 value get //访问 set //修改 注意: value和writable与get和set不能共存 obj.prop 调用get方法 obj.prop = ‘xxx’ 调用set方法","categories":[],"tags":[]},{"title":"NVM_Node_NPM_CNPM安装","slug":"NVM-Node-NPM-CNPM安装","date":"2019-10-10T05:36:11.000Z","updated":"2019-10-10T12:32:30.867Z","comments":true,"path":"2019/10/10/NVM-Node-NPM-CNPM安装/","link":"","permalink":"http://yoursite.com/2019/10/10/NVM-Node-NPM-CNPM安装/","excerpt":"NVM-windows安装第一步:下载NVM安装包:https://github.com/coreybutler/nvm-windows/releases第二步:创建俩个文件目录,解压安装包到NVM目录中:D:\\NVMD:\\Node","text":"NVM-windows安装第一步:下载NVM安装包:https://github.com/coreybutler/nvm-windows/releases第二步:创建俩个文件目录,解压安装包到NVM目录中:D:\\NVMD:\\Node 第三步:进入NVM目录双击 install.cmd 直接回车第四步:修改setting.txt文件复制到D:\\NVM目录中root: D:\\NVMpath: D:\\Nodearch: 64proxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/第五步:配置环境变量NVM_HOME和NVM_SYMLINKNVM_HOME : D:\\NVMNVM_SYMLINK : D:\\Node第六步:path中添加变量%NVM_HOME%%NVM_SYMLINK%第七步:查看NVM版本信息nvm -vNode-windows安装第一步:安装Node(为了后续安装全局npm准备)nvm install 6.15.0第二步:使用Nodenvm use 6.15.0第三步:在nvm\\node_dir下创建node_cache和node_global文件加第四步配置缓冲路径和全局路径(使C:\\Users\\yi081.npmrc 】文件重新生成)npm config set prefix “D:\\NVM\\node_dir\\node_global”npm config set cache “D:\\NVM\\node_dir\\node_cache”第五步:配置Node环境变量NODE_HOME和NODE_PATHNODE_HOME:D:\\Node\\node_modulesNODE_GLOBAL:D:\\NVM\\node_dir\\node_global (可不配置)NODE_PATH : D:\\NVM\\node_dir\\node_global\\node_modules第六步:添加到path中%NODE_HOME%%NODE_GLOBAL% (可不配置)%NODE_PATH%全局安装NPM第一步:下载npmnpm install npm@latest -g第二步:配置NPM环境变量NPM_HOME : D:\\NVM\\node_dir\\node_global\\npm第三步:添加到path中%NPM_HOME%全局安装CNPM第一步:下载cnpmnpm install -g cnpm –registry=https://registry.npm.taobao.org第二步:配置CNPM环境变量(可不配置)CNPM_HOME : D:\\NVM\\node_dir\\node_global\\cnpm第三步:添加到path中(可不配置)%NPM_HOME%","categories":[],"tags":[]}]}