{"meta":{"title":"爱编程-爱挑战-爱学习","subtitle":null,"description":"程序员就是我,我就是程序元","author":"TWei","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-10-10T08:40:58.000Z","updated":"2019-10-10T08:41:21.127Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-10T08:40:06.000Z","updated":"2019-10-10T08:40:46.724Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue之深入响应式原理","slug":"Vue之深入响应式原理","date":"2019-10-13T02:41:02.000Z","updated":"2019-10-13T02:41:45.402Z","comments":true,"path":"2019/10/13/Vue之深入响应式原理/","link":"","permalink":"http://yoursite.com/2019/10/13/Vue之深入响应式原理/","excerpt":"理解Vue响应式原理,只需通过解决以下几个问题即可 如何实现数据劫持? 如何实现数据代理?(如何对this.xxx的访问代理到this.data.xxx上?) 如何实现数据编译? 如何实现发布订阅模式? 如何实现更新视图?(如何监听数据的读写操作?如何实现数据修改DOM更新?) 如何实现双向数据绑定? 如何实现依赖缓存? template改变的时候,如何清理依赖项集合?eg:v-if和组件销毁","text":"理解Vue响应式原理,只需通过解决以下几个问题即可 如何实现数据劫持? 如何实现数据代理?(如何对this.xxx的访问代理到this.data.xxx上?) 如何实现数据编译? 如何实现发布订阅模式? 如何实现更新视图?(如何监听数据的读写操作?如何实现数据修改DOM更新?) 如何实现双向数据绑定? 如何实现依赖缓存? template改变的时候,如何清理依赖项集合?eg:v-if和组件销毁 前提1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; a.a &#125;&#125;&lt;/p&gt; &lt;span&gt;&#123;&#123; b &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;const vm = new Mvvm(&#123; el: &apos;#app&apos;, data: &#123; a: &#123; a: &apos;我是a&apos; &#125;, b: &apos;我是b&apos; &#125; &#125;)&lt;/script&gt; 问题:如何实现数据劫持答:通过Object.defineProperty()方法,对data中的属性,在访问或者修改对象的其中某个属性时,通过一段代码拦截这个行为,进行额外的操作或者修改返回结果 12345678910111213141516171819202122232425262728293031323334353637// TODO:1.定义Mvvm类function Mvvm(options=&#123;&#125;)&#123; // TODO:this代表的是fade实例对象 // TODO:将所有属性挂载到$options this.$options = options var data = this._data = this.options.data // TODO:调用数据劫持 observe(data)&#125;// TODO:3.观察者function Observe(obj)&#123; for (let key in obj) &#123; let val = obj[key] // TODO:深度劫持 observe(val) Object.defineProperty(obj,key,&#123; enumerable : true, get()&#123; return val &#125;, set(newVal)&#123; if (newVal === val) return val = newVal // TODO:深度劫持 observe(newVal) &#125; &#125;) &#125;&#125;// TODO:2.数据劫持-使每个对象都具有get和set方法function observe(vmData)&#123; if (typeof data !== &apos;object&apos;) return return new Observe(vmData)&#125; 问题:如何实现数据代理-如何对this.xxx的访问代理到this.data.xxx上?答:对于每个data上的属性,都在app上做一个代理,实际操作的是this.data实现的代码如下: 1234567891011121314151617181920function Mvvm(options = &#123;&#125;) &#123; // TODO:this代表的是zhufeng实例对象 // TODO:将所有属性挂载到$options this.$options = options //this._data var data = this._data = this.$options.data observe(data) // TODO:4.数据代理 for (let key in data) &#123; Object.defineProperty(this,key,&#123; enumerable : true, get()&#123; return this._data[key] &#125;, set(newVal)&#123; this._data[key] = newVal &#125; &#125;) &#125;&#125; 问题:如何实现数据编译答:通过获取vm管理DOM的根节点,让其在内存中完成相关的正则匹配工作,替换DOM中的文本节点 123456789101112131415161718192021222324252627282930// TODO:5数据编译function Compile(el,vm)&#123; vm.$el = document.querySelector(el) let fragment = document.createDocumentFragment() while (child = vm.$el.firstChild) &#123; fragment.appendChild(child) &#125; replace(fragment) // TODO:6.数据替换 function replace(frag)&#123; Array.from(frag.childNodes).forEach(function (node) &#123; let text = node.textContent let regExp = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/ if (node.nodeType === 1 &amp;&amp; regExp.test(text)) &#123; let arr = RegExp.$1.trim().split(&apos;.&apos;) let val = vm arr.forEach(function (k) &#123; val = val[k] &#125;) node.textContent = text.replace(regExp,val).trim() &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; replace(node) &#125; &#125;) &#125; vm.$el.appendChild(fragment)&#125; 12345function Mvvm(options = &#123;&#125;) &#123; .... // TODO:进行编译 new Compile(optionns.el,this)&#125; 问题:如何实现发布订阅模式答:发布订阅主要靠的就是数组关系，订阅就是放入函数，发布就是让数组里的函数执行 12345678910111213141516171819202122// TODO:8.发布订阅模式// TODO:桥梁function Dep()&#123; // 桥梁 this.subs = [] // 订阅事件池&#125;// TODO:进行订阅的方法(往里面扔函数)Dep.property.addSub = function (sub) &#123; //sub就是watcher this.subs.push(sub)&#125;// TODO:进行发布/通知的方法(让函数的每一项一次执行)Dep.prototype.notify = function () &#123; this.subs.forEach(sub =&gt; sub.update())//绑定的事件,都有一个update属性&#125;// TODO:订阅者function Watcher(fn)&#123; //Watcher是一个类,通过这个类创建的实例都拥有update方法 this.fn = fn&#125;Watcher.prototype.update = function () &#123; //调用fn() this.fn()&#125; 问题:如何更新视图-当数据改变需要重新刷新视图答:现在我们要订阅一个事件，当数据改变需要重新刷新视图，这就需要在replace替换的逻辑里来处理通过new Watcher把数据订阅一下，数据一变就执行改变内容的操作 监听变化 123456789101112131415// TODO:6.数据替换 function replace(frag) &#123; ... node.textContent = text.replace(regExp, val).trim() // TODO:监听变化 new Watcher(vm,RegExp.$1,function (newVal) &#123; node.textContent = text.replace(regExp,newVal).trim() &#125;) if (node.childNodes &amp;&amp; node.childNodes.length) &#123; replace(node) &#125; ... &#125; 重写Watcher构造函数 1234567891011121314// TODO:订阅者function Watcher(vm,exp,fn)&#123; //Watcher是一个类,通过这个类创建的实例都拥有update方法 this.fn = fn this.vm = vm this.exp = exp Dep.target = this let arr = exp.trim().split(&apos;.&apos;) let val = vm arr.forEach(function (key) &#123; val = val[key] &#125;) Dep.target = null // // 上面获取val[key]的时候会调用get方法, 因此使用完毕之后需要把该属性置为null&#125; 重写数据劫持get和set方法 解:当获取值的时候就会自动调用get方法，于是我们去找一下数据劫持那里的get方法123456789101112131415161718192021222324252627// TODO:3.观察者function Observe(obj)&#123; // TODO:创建桥梁 let dep = new Dep() for (let key in obj) &#123; let val = obj[key] // TODO:深度劫持 observe(val) Object.defineProperty(obj,key,&#123; enumerable : true, get()&#123; // TODO:将watcher添加到订阅事件中 [watcher] Dep.target &amp;&amp; dep.addSub(Dep.target) return val &#125;, set(newVal)&#123; // 更改值得时候 if (newVal === val) return // 设置的值和以前的是一样的东西 val = newVal // 如果以后在获取值的时候将刚才设置的值丢回去 // TODO:深度劫持 observe(newVal) // TODO:执行update方法 dep.notify() &#125; &#125;) &#125;&#125; 修改watcher的update方法 解:当set修改值的时候执行了dep.notify方法，这个方法是执行watcher的update方法，那么我们再对update进行修改一下1234567891011Watcher.prototype.update = function () &#123; //调用fn() this.fn() // notify的时候值已经更改了 // 再通过vm, exp来获取新的值 let arr = this.exp.trim().split(&apos;.&apos;) let val = this.vm arr.forEach(function(key)&#123; val = val[key] &#125;) this.fn(val) // 将每次拿到的新值去替换&#123;&#123;&#125;&#125;的内容即可&#125; 问题:双向数据绑定","categories":[],"tags":[]},{"title":"标准网页标签模板及其每个标签的作用","slug":"标准网页标签模板及其每个标签的作用","date":"2019-10-12T15:06:27.000Z","updated":"2019-10-13T02:38:02.599Z","comments":true,"path":"2019/10/12/标准网页标签模板及其每个标签的作用/","link":"","permalink":"http://yoursite.com/2019/10/12/标准网页标签模板及其每个标签的作用/","excerpt":"12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt; + 声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。 + 通过document.compatMode查看模式： + BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。 + CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。 &lt;html lang=&quot;en/zh-CN&quot;&gt; + lang=&quot;en&quot; 向搜索引擎表示该页面是html语言，并且语言为英文网站,并提示浏览器是否进行翻译 + lang=&quot;zh-CN&quot; 向搜索引擎表示该页面是html语言，并且语言为中文网站&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;/&gt; + 声明文档使用的字符编码&lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;&gt; + 移动端布局&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; + 告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面或告诉浏览器用chrome内核来渲染&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;/&gt; + 指定双核浏览器默认以何种方式渲染页面&lt;title&gt;&lt;/title&gt; + 标题&lt;meta name=&quot;description&quot; content=&quot;#[[$description$]]#&quot;/&gt; + 描述&lt;meta name=&quot;keyword&quot; content=&quot;#[[$keyword$]]#&quot;/&gt; + 关键字&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/body&gt;","text":"12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt; + 声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。 + 通过document.compatMode查看模式： + BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。 + CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。 &lt;html lang=&quot;en/zh-CN&quot;&gt; + lang=&quot;en&quot; 向搜索引擎表示该页面是html语言，并且语言为英文网站,并提示浏览器是否进行翻译 + lang=&quot;zh-CN&quot; 向搜索引擎表示该页面是html语言，并且语言为中文网站&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;/&gt; + 声明文档使用的字符编码&lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;&gt; + 移动端布局&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; + 告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面或告诉浏览器用chrome内核来渲染&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;/&gt; + 指定双核浏览器默认以何种方式渲染页面&lt;title&gt;&lt;/title&gt; + 标题&lt;meta name=&quot;description&quot; content=&quot;#[[$description$]]#&quot;/&gt; + 描述&lt;meta name=&quot;keyword&quot; content=&quot;#[[$keyword$]]#&quot;/&gt; + 关键字&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/body&gt;","categories":[],"tags":[]},{"title":"前端高度塌陷问题","slug":"前端高度塌陷问题","date":"2019-10-12T07:22:43.000Z","updated":"2019-10-13T02:36:48.264Z","comments":true,"path":"2019/10/12/前端高度塌陷问题/","link":"","permalink":"http://yoursite.com/2019/10/12/前端高度塌陷问题/","excerpt":"一.产生原因 在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。","text":"一.产生原因 在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。 二.所以在开发中一定要避免出现高度塌陷的问题, 1.我们可以将父元素的高度写死，以避免塌陷的问题出现， 但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。 2.根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。 (1)当开启元素的BFC以后，元素将会具有如下的特性： 父元素的垂直外边距不会和子元素重叠 开启BFC的元素不会被浮动元素所覆盖 开启BFC的元素可以包含浮动的子元素 (2)如何开启元素的BFC 设置元素浮动 1使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失而且使用这种方式也会导致下边的元素上移，不能解决问题 设置元素绝对定位 设置元素为inline-block 1可以解决问题，但是会导致宽度丢失，不推荐使用这种方式 将元素的overflow设置为一个非visible的值 123456推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式,但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题开启方式很多，我们直接使用一种副作用最小的： 直接将元素的zoom设置为1即可 zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍 zoom:1表示不放大元素，但是通过该样式可以开启hasLayout zoom这个样式，只在IE中支持，其他浏览器都不支持 最终兼容方案 1234.clearfix&#123; overflow: hidden; zoom:1;&#125; 3.通过在高度塌陷的父元素的最后，添加一个空白的div,然后在对其进行清除浮动,但会在页面中添加多余结构 由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后在对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用,使用这种方式虽然可以解决问题，但是会在页面中添加多余的结构。 最终方案123.clearfix&#123; clear: both;&#125; 4.通过after伪类在高度塌陷的父元素的最后,添加一个空白的块元素，然后对其清除浮动，不会再页面中添加多余结构 这样做和添加一个div的原理一样，可以达到一个相同的效果，而且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用 12345678 .clearfix:after&#123; // 添加一个内容 content: &quot;&quot;; // 转换为一个块元素 display: block; // 清除两侧的浮动 clear: both;&#125; 在IE6中不支持after伪类,所以在IE6中还需要使用hasLayout来处理12345678.clearfix&#123; zoom:1;&#125;.clearfix:after&#123; content: &quot;&quot;; display: block; clear: both;&#125; 5.子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素,使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠 解决父子元素的外边距重叠 1234.box1:before&#123; content: &quot;&quot;; display:table可以将一个元素设置为表格显示&#125; 解决父元素高度塌陷 12345678.clearfix&#123; zoom:1;&#125;.clearfix:after&#123; content: &quot;&quot;; display: block; clear: both;&#125; 经过修改后的clearfix是一个多功能的既可以解决高度塌陷，又可以确保父元素和子元素的垂直外边距不会重叠 123456789.clearfix&#123; zoom: 1;&#125;.clearfix:before,.clearfix:after&#123; content: &quot;&quot;; display: table; clear: both;&#125;","categories":[],"tags":[]},{"title":"了解Object.defineProperty()方法","slug":"了解Object-defineProperty-方法","date":"2019-10-10T15:44:19.000Z","updated":"2019-10-13T02:38:58.469Z","comments":true,"path":"2019/10/10/了解Object-defineProperty-方法/","link":"","permalink":"http://yoursite.com/2019/10/10/了解Object-defineProperty-方法/","excerpt":"Object.defineProperty(obj,prop,descriptor)1.参数 obj 要在其上定义属性的对象。 prop 要定义或修改的属性的名称。 descriptor 将被定义或修改的属性描述符。 2.返回值 被传递给函数的对象obj","text":"Object.defineProperty(obj,prop,descriptor)1.参数 obj 要在其上定义属性的对象。 prop 要定义或修改的属性的名称。 descriptor 将被定义或修改的属性描述符。 2.返回值 被传递给函数的对象obj 3.属性描述符 configurable // 可删除 enumerable // 可枚举 writable // 可赋值 value get // 访问 set // 修改 注意: value和writable与get和set不能共存 obj.prop 调用get方法 obj.prop = ‘xxx’ 调用set方法","categories":[],"tags":[]},{"title":"NVM_Node_NPM_CNPM安装","slug":"NVM-Node-NPM-CNPM安装","date":"2019-10-10T05:36:11.000Z","updated":"2019-10-10T12:32:30.867Z","comments":true,"path":"2019/10/10/NVM-Node-NPM-CNPM安装/","link":"","permalink":"http://yoursite.com/2019/10/10/NVM-Node-NPM-CNPM安装/","excerpt":"NVM-windows安装第一步:下载NVM安装包:https://github.com/coreybutler/nvm-windows/releases第二步:创建俩个文件目录,解压安装包到NVM目录中:D:\\NVMD:\\Node","text":"NVM-windows安装第一步:下载NVM安装包:https://github.com/coreybutler/nvm-windows/releases第二步:创建俩个文件目录,解压安装包到NVM目录中:D:\\NVMD:\\Node 第三步:进入NVM目录双击 install.cmd 直接回车第四步:修改setting.txt文件复制到D:\\NVM目录中root: D:\\NVMpath: D:\\Nodearch: 64proxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/第五步:配置环境变量NVM_HOME和NVM_SYMLINKNVM_HOME : D:\\NVMNVM_SYMLINK : D:\\Node第六步:path中添加变量%NVM_HOME%%NVM_SYMLINK%第七步:查看NVM版本信息nvm -vNode-windows安装第一步:安装Node(为了后续安装全局npm准备)nvm install 6.15.0第二步:使用Nodenvm use 6.15.0第三步:在nvm\\node_dir下创建node_cache和node_global文件加第四步配置缓冲路径和全局路径(使C:\\Users\\yi081.npmrc 】文件重新生成)npm config set prefix “D:\\NVM\\node_dir\\node_global”npm config set cache “D:\\NVM\\node_dir\\node_cache”第五步:配置Node环境变量NODE_HOME和NODE_PATHNODE_HOME:D:\\Node\\node_modulesNODE_GLOBAL:D:\\NVM\\node_dir\\node_global (可不配置)NODE_PATH : D:\\NVM\\node_dir\\node_global\\node_modules第六步:添加到path中%NODE_HOME%%NODE_GLOBAL% (可不配置)%NODE_PATH%全局安装NPM第一步:下载npmnpm install npm@latest -g第二步:配置NPM环境变量NPM_HOME : D:\\NVM\\node_dir\\node_global\\npm第三步:添加到path中%NPM_HOME%全局安装CNPM第一步:下载cnpmnpm install -g cnpm –registry=https://registry.npm.taobao.org第二步:配置CNPM环境变量(可不配置)CNPM_HOME : D:\\NVM\\node_dir\\node_global\\cnpm第三步:添加到path中(可不配置)%NPM_HOME%","categories":[],"tags":[]}]}