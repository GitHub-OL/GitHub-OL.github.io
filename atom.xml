<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱编程-爱挑战-爱学习</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-15T15:34:31.830Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TWei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>03CSS定位</title>
    <link href="http://yoursite.com/2019/10/15/03CSS%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2019/10/15/03CSS定位/</id>
    <published>2019-10-15T15:33:34.000Z</published>
    <updated>2019-10-15T15:34:31.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-CSS定位"><a href="#一-CSS定位" class="headerlink" title="一.CSS定位"></a>一.CSS定位</h3><p>元素定位属性主要包括:定位模式和边偏移两部分</p><h4 id="1-定位模式"><a href="#1-定位模式" class="headerlink" title="1.定位模式"></a>1.定位模式</h4><p><strong>语法:display:static|relative|absolute|fixed</strong></p><ul><li>static    自动定位（默认定位方式）</li><li>relative    相对定位，相对于其原文档流的位置进行定位</li><li>absolute    绝对定位，相对于其上一个已经定位的父元素进行定位</li><li>fixed        固定定位，相对于浏览器窗口进行定位<a id="more"></a></li></ul><h4 id="2-边偏移"><a href="#2-边偏移" class="headerlink" title="2.边偏移"></a>2.边偏移</h4><ul><li>top        顶端偏移量，定义元素相对于其父元素上边线的距离</li><li>bottom    底部偏移量，定义元素相对于其父元素下边线的距离</li><li>left        左侧偏移量，定义元素相对于其父元素左边线的距离</li><li>right        右侧偏移量，定义元素相对于其父元素右边线的距离</li></ul><h3 id="二-定位的分类"><a href="#二-定位的分类" class="headerlink" title="二.定位的分类"></a>二.定位的分类</h3><h4 id="1-静态定位"><a href="#1-静态定位" class="headerlink" title="1.静态定位"></a>1.静态定位</h4><ul><li>参考对象:HTML文档流中默认的位置</li><li>边偏移属性无效</li></ul><h4 id="2-相对定位"><a href="#2-相对定位" class="headerlink" title="2.相对定位"></a>2.相对定位</h4><ul><li>参考对象:元素原先在文档流中的位置</li><li>相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有</li><li>每次移动的位置，是以自己的左上角为基点移动（相对于自己来移动位置）</li><li>相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。（相对定位不脱标）</li></ul><h3 id="3-绝对定位"><a href="#3-绝对定位" class="headerlink" title="3.绝对定位"></a>3.绝对定位</h3><ul><li>参考对象:最近的祖先定位元素/浏览器窗口</li><li>通过边偏移移动位置，完全脱标，完全不占位置</li><li>跟随文档滚动而滚动,子绝父相</li><li>绝对定位水平居中左右margin:auto无效</li><li>转换为行内-块级元素<ul><li>left:50% (父元素宽度的一半)</li><li>margin-left:-(本元素宽度/2)</li></ul></li></ul><h4 id="4-固定定位"><a href="#4-固定定位" class="headerlink" title="4.固定定位"></a>4.固定定位</h4><ul><li>参考对象:浏览器可视窗口</li><li>固定定位的元素跟父亲没有任何关系，只认浏览器可视窗口</li><li>固定定位完全脱标，不占有位置，不随滚动条滚动而滚动</li><li>固定定位一定要写宽、高，除非有内容撑开,</li><li>IE6等低版本浏览器不支持固定定位</li><li>转换为行内-块级元素</li></ul><h3 id="三-层级"><a href="#三-层级" class="headerlink" title="三.层级"></a>三.层级</h3><h4 id="1-层级设置方法"><a href="#1-层级设置方法" class="headerlink" title="1.层级设置方法"></a>1.层级设置方法</h4><ul><li>给盒子一个CSS定位（除静态定位都可以)</li><li>设置盒子z-index：xxx;的值</li><li>只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。</li></ul><h4 id="2-层级比较"><a href="#2-层级比较" class="headerlink" title="2.层级比较"></a>2.层级比较</h4><p><strong>盒子层级</strong>：标准流&lt;浮动流&lt;定位流</p><ul><li>不给层级的时候默认层级为0</li><li>层级为0的盒子比浮动的和标准流的高</li><li>层级为负数的盒子比浮动的和标准流的低，层级不能为小数。</li><li>层级一样后面的盒子比前面的高。</li><li>标准流中的文字比浮动盒子层级高。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-CSS定位&quot;&gt;&lt;a href=&quot;#一-CSS定位&quot; class=&quot;headerlink&quot; title=&quot;一.CSS定位&quot;&gt;&lt;/a&gt;一.CSS定位&lt;/h3&gt;&lt;p&gt;元素定位属性主要包括:定位模式和边偏移两部分&lt;/p&gt;
&lt;h4 id=&quot;1-定位模式&quot;&gt;&lt;a href=&quot;#1-定位模式&quot; class=&quot;headerlink&quot; title=&quot;1.定位模式&quot;&gt;&lt;/a&gt;1.定位模式&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;语法:display:static|relative|absolute|fixed&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;static    自动定位（默认定位方式）&lt;/li&gt;
&lt;li&gt;relative    相对定位，相对于其原文档流的位置进行定位&lt;/li&gt;
&lt;li&gt;absolute    绝对定位，相对于其上一个已经定位的父元素进行定位&lt;/li&gt;
&lt;li&gt;fixed        固定定位，相对于浏览器窗口进行定位
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>三种隐藏元素方法的区别</title>
    <link href="http://yoursite.com/2019/10/15/%E4%B8%89%E7%A7%8D%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/10/15/三种隐藏元素方法的区别/</id>
    <published>2019-10-15T08:47:42.000Z</published>
    <updated>2019-10-15T08:49:35.557Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>display:none</strong> <ul><li>元素在页面上将消失,不占据页面空间,会导致浏览器的回流与重绘,不能响应交互类事件；<a id="more"></a></li></ul></li><li><strong>visibility:hidden</strong>   <ul><li>元素在页面占据的空间不变,所以它只会导致浏览器重绘而不会回流,也不能响应交互类事件；</li></ul></li><li><strong>opacity:0</strong>    <ul><li>元素在页面占据的空间不变，不会导致浏览器回流或重绘（因为浏览器对于transform和opacity这两种变化处理的方法为合成渲染,可以响应交互类事件。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;display:none&lt;/strong&gt; &lt;ul&gt;
&lt;li&gt;元素在页面上将消失,不占据页面空间,会导致浏览器的回流与重绘,不能响应交互类事件；
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>02CSS浮动</title>
    <link href="http://yoursite.com/2019/10/15/02CSS%E6%B5%AE%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/10/15/02CSS浮动/</id>
    <published>2019-10-15T08:47:22.000Z</published>
    <updated>2019-10-15T08:49:00.635Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-CSS浮动是什么"><a href="#一-CSS浮动是什么" class="headerlink" title="一.CSS浮动是什么?"></a>一.CSS浮动是什么?</h3><p>css浮动就是浮动元素会脱离文档的普通流,根据float的值向左或向右移动,直到它的外边界碰到父元素的内边界或另一个浮动元素的外边界为止</p><h4 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1.相关概念"></a>1.相关概念</h4><ul><li>标准文档流:普通流/文档流</li><li>脱标:脱离标准流</li><li>CSS中一共有三种脱标手段:<a id="more"></a><ul><li>浮动</li><li>绝对定位</li><li>固定定位</li></ul></li><li>网页布局的三种流<ul><li>文档流</li><li>浮动流</li><li>定位流</li></ul></li></ul><h3 id="二-浮动"><a href="#二-浮动" class="headerlink" title="二.浮动"></a>二.浮动</h3><h4 id="1-浮动API"><a href="#1-浮动API" class="headerlink" title="1.浮动API"></a>1.浮动API</h4><p><strong>语法： float : none | left | right</strong></p><ul><li>none:元素不浮动</li><li>left:元素向左浮动</li><li>right:元素向右浮动</li></ul><h4 id="2-浮动规则"><a href="#2-浮动规则" class="headerlink" title="2.浮动规则"></a>2.浮动规则</h4><ul><li>浮动元素位于文档流之上,会遮挡文档流</li><li>如果同为浮动元素,会从左向右/从右向左,自上而下依次排列,会被高度高的浮动元素卡住</li><li>如果上一个元素为文档流中的元素,浮动元素的相对垂直位置不变,与文档流元素底部对齐(浮动元素不会超过它前边未进行浮动元素的底部)        </li><li>浮动流只有一种排版方式,就是水平排版,它只能设置某个元素左对齐或者右对齐,在浮动流中是不可以使用margin: 0 auto;</li><li>如果同一行中左右浮动都存在,位置不够时,右浮动元素的后边元素会向下排列,左浮动先会保持不变,只有当宽度容不下左浮动元素的宽度,左浮动元素才会向下移动</li></ul><h4 id="3-浮动特性"><a href="#3-浮动特性" class="headerlink" title="3.浮动特性"></a>3.浮动特性</h4><ul><li>元素浮动以后变成行内块元素</li><li>元素浮动以后后边如果是行内元素或者行内-块级元素(两者视为文本),浮动元素不会遮挡文本</li><li>元素浮动以后后边如果块级元素(里面包含文本)/块级元素内部包含行内元素或者行内-块级元素,浮动元素不会遮挡<br>文本</li></ul><h3 id="三-清除浮动"><a href="#三-清除浮动" class="headerlink" title="三.清除浮动"></a>三.清除浮动</h3><h4 id="1-清除浮动API"><a href="#1-清除浮动API" class="headerlink" title="1.清除浮动API"></a>1.清除浮动API</h4><p><strong>语法： clear : none | left | right | both</strong></p><ul><li>none:允许两边有浮动元素</li><li>left:不允许左边有浮动元素</li><li>right:不允许右边有浮动元素</li><li>both:不允许两边有浮动元素(左边|右边|两边)</li></ul><h4 id="2-清除浮动规则"><a href="#2-清除浮动规则" class="headerlink" title="2.清除浮动规则"></a>2.清除浮动规则</h4><ul><li>只能作用于块级元素或浮动元素</li><li>浮动只能影响调用它的元素</li><li>清除浮动不能作用域行内/行内-块级元素,因为浮动元素不会遮挡行内/行内-块级元素</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-CSS浮动是什么&quot;&gt;&lt;a href=&quot;#一-CSS浮动是什么&quot; class=&quot;headerlink&quot; title=&quot;一.CSS浮动是什么?&quot;&gt;&lt;/a&gt;一.CSS浮动是什么?&lt;/h3&gt;&lt;p&gt;css浮动就是浮动元素会脱离文档的普通流,根据float的值向左或向右移动,直到它的外边界碰到父元素的内边界或另一个浮动元素的外边界为止&lt;/p&gt;
&lt;h4 id=&quot;1-相关概念&quot;&gt;&lt;a href=&quot;#1-相关概念&quot; class=&quot;headerlink&quot; title=&quot;1.相关概念&quot;&gt;&lt;/a&gt;1.相关概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;标准文档流:普通流/文档流&lt;/li&gt;
&lt;li&gt;脱标:脱离标准流&lt;/li&gt;
&lt;li&gt;CSS中一共有三种脱标手段:
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>01标准文档流</title>
    <link href="http://yoursite.com/2019/10/15/01%E6%A0%87%E5%87%86%E6%96%87%E6%A1%A3%E6%B5%81/"/>
    <id>http://yoursite.com/2019/10/15/01标准文档流/</id>
    <published>2019-10-15T08:47:05.000Z</published>
    <updated>2019-10-15T15:34:05.885Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML元素分类"><a href="#HTML元素分类" class="headerlink" title="HTML元素分类"></a>HTML元素分类</h3><ul><li><strong>块级元素</strong><ul><li>独占一行,自上向下排列</li><li>默认宽度为父元素的100%</li><li>默认高度被内容撑开</li><li>可设置高/宽/内边距/外边距<a id="more"></a></li></ul></li><li><strong>行内元素</strong><ul><li>和其他非块级元素在同一行 </li><li>只占自身大小,从左到右,自上向下排列</li><li>宽度和高度被内容撑开</li><li>不可设置高/宽/上下内边距/上下外边距</li></ul></li><li><strong>行内-块级元素</strong>即置换元素<ul><li>和其他非块级元素在同一行</li><li>从左到右,自上向下排列</li><li>可设置高/宽/内边距/外边距</li></ul></li><li><strong>注意事项</strong><ul><li><strong>行内元素</strong>:设置上下内边距,显示效果是增加了,只不过是表象,设置是无效的,对周围元素无任何影响,但设置背景会覆盖周围元素</li><li><strong>行内块级元素</strong>:设置行高会影响同行相同元素类型的行高,与其保持一致</li><li><strong>行内元素/行内-块级元素</strong>:进行页面布局的时候会把空的文本节点计算在内</li><li><strong>置换元素</strong>:是指浏览器根据元素的标签和属性，来决定元素的具体显示内容,<strong>可以设置高宽/内外边距</strong>,性质同设置了display:inline-block的元素一致。而img元素虽然是行内元素 但它也是置换元素<ul><li>html中的img,input,textarea,select,object都是置换元素，这些置换元素往往没有实际内容，即是一个空元素。 </li><li>例如：浏览器根据<strong>img标</strong>签的src属性显示图片。根据<strong>input标签</strong>的type属性决定显示输入框还是按钮  </li></ul></li><li><strong>非置换元素</strong>:浏览器中的大多数元素都是不可置换元素，即其内容直接展示给浏览器</li><li><strong>h1~h6/p/dt元素</strong>:只能包含行内元素，不能再包含块级元素</li></ul></li></ul><h3 id="块级元素和行内元素的嵌套规范-规则"><a href="#块级元素和行内元素的嵌套规范-规则" class="headerlink" title="块级元素和行内元素的嵌套规范(规则)"></a>块级元素和行内元素的嵌套规范(规则)</h3><ul><li>行内元素可以嵌套行内元素,不可以嵌套块级元素</li><li>块级元素,可以嵌套块级元素,或者是行内元素</li><li>部分块级元素,不能嵌套块级元素,只能嵌套行内元素,如:p、h1-h6、dt(p是真正的不能,其余的是规范的问题)</li><li>块级元素中嵌套的元素,块级元素和块级元素一级,行内元素和行内元素一级</li></ul><h3 id="HTML元素转换API"><a href="#HTML元素转换API" class="headerlink" title="HTML元素转换API"></a>HTML元素转换API</h3><p><strong>语法： display : none | block | inline | inline-block</strong></p><ul><li>none:此元素不会被显示(隐藏渲染)</li><li>block:此元素将显示为块级元素</li><li>inline:此元素将显示为行内元素</li><li>inline-block:此元素将显示为行内-块级元素</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTML元素分类&quot;&gt;&lt;a href=&quot;#HTML元素分类&quot; class=&quot;headerlink&quot; title=&quot;HTML元素分类&quot;&gt;&lt;/a&gt;HTML元素分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;块级元素&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;独占一行,自上向下排列&lt;/li&gt;
&lt;li&gt;默认宽度为父元素的100%&lt;/li&gt;
&lt;li&gt;默认高度被内容撑开&lt;/li&gt;
&lt;li&gt;可设置高/宽/内边距/外边距
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue之深入响应式原理</title>
    <link href="http://yoursite.com/2019/10/13/Vue%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/10/13/Vue之深入响应式原理/</id>
    <published>2019-10-13T02:41:02.000Z</published>
    <updated>2019-10-13T02:46:10.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解Vue响应式原理-只需通过解决以下几个问题即可"><a href="#理解Vue响应式原理-只需通过解决以下几个问题即可" class="headerlink" title="理解Vue响应式原理,只需通过解决以下几个问题即可"></a>理解Vue响应式原理,只需通过解决以下几个问题即可</h3><ul><li>如何实现数据劫持?</li><li>如何实现数据代理?(如何对this.xxx的访问代理到this.data.xxx上?)</li><li>如何实现数据编译?</li><li>如何实现发布订阅模式?</li><li>如何实现更新视图?(如何监听数据的读写操作?如何实现数据修改DOM更新?)</li><li>如何实现双向数据绑定?</li><li>如何实现依赖缓存?</li><li>template改变的时候,如何清理依赖项集合?eg:v-if和组件销毁<a id="more"></a></li></ul><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; a.a &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; b &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const vm = new Mvvm(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      a: &#123;</span><br><span class="line">        a: &apos;我是a&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      b: &apos;我是b&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="问题-如何实现数据劫持"><a href="#问题-如何实现数据劫持" class="headerlink" title="问题:如何实现数据劫持"></a>问题:如何实现数据劫持</h3><p>答:通过Object.defineProperty()方法,对data中的属性,在访问或者修改对象的其中某个属性时,通过一段代码拦截这个行为,进行额外的操作或者修改返回结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// TODO:1.定义Mvvm类</span><br><span class="line">function Mvvm(options=&#123;&#125;)&#123;</span><br><span class="line">    // TODO:this代表的是fade实例对象</span><br><span class="line">    // TODO:将所有属性挂载到$options</span><br><span class="line">    this.$options = options</span><br><span class="line">    var data = this._data = this.options.data</span><br><span class="line">    // TODO:调用数据劫持</span><br><span class="line">    observe(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO:3.观察者</span><br><span class="line">function Observe(obj)&#123;</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    let val = obj[key]</span><br><span class="line">    // TODO:深度劫持</span><br><span class="line">    observe(val)</span><br><span class="line">    </span><br><span class="line">    Object.defineProperty(obj,key,&#123;</span><br><span class="line">      enumerable : true,</span><br><span class="line">      get()&#123;</span><br><span class="line">        return val</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newVal)&#123;</span><br><span class="line">        if (newVal === val) return</span><br><span class="line">        val = newVal</span><br><span class="line">        // TODO:深度劫持</span><br><span class="line">        observe(newVal)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO:2.数据劫持-使每个对象都具有get和set方法</span><br><span class="line">function observe(vmData)&#123;</span><br><span class="line">  if (typeof data !== &apos;object&apos;) return</span><br><span class="line">  return new Observe(vmData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-如何实现数据代理-如何对this-xxx的访问代理到this-data-xxx上"><a href="#问题-如何实现数据代理-如何对this-xxx的访问代理到this-data-xxx上" class="headerlink" title="问题:如何实现数据代理-如何对this.xxx的访问代理到this.data.xxx上?"></a>问题:如何实现数据代理-如何对this.xxx的访问代理到this.data.xxx上?</h3><p>答:对于每个data上的属性,都在app上做一个代理,实际操作的是this.data<br>实现的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Mvvm(options = &#123;&#125;) &#123;</span><br><span class="line">  // TODO:this代表的是zhufeng实例对象</span><br><span class="line">  // TODO:将所有属性挂载到$options</span><br><span class="line">  this.$options = options</span><br><span class="line">  //this._data</span><br><span class="line">  var data = this._data = this.$options.data</span><br><span class="line">  observe(data) </span><br><span class="line">  // TODO:4.数据代理</span><br><span class="line">  for (let key in data) &#123;</span><br><span class="line">    Object.defineProperty(this,key,&#123;</span><br><span class="line">      enumerable : true,</span><br><span class="line">      get()&#123;</span><br><span class="line">        return this._data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newVal)&#123;</span><br><span class="line">        this._data[key] = newVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-如何实现数据编译"><a href="#问题-如何实现数据编译" class="headerlink" title="问题:如何实现数据编译"></a>问题:如何实现数据编译</h3><p>答:通过获取vm管理DOM的根节点,让其在内存中完成相关的正则匹配工作,替换DOM中的文本节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// TODO:5数据编译</span><br><span class="line">function Compile(el,vm)&#123;</span><br><span class="line">  vm.$el = document.querySelector(el)</span><br><span class="line">  let fragment = document.createDocumentFragment()</span><br><span class="line">  while (child = vm.$el.firstChild) &#123;</span><br><span class="line">    fragment.appendChild(child)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  replace(fragment)</span><br><span class="line"></span><br><span class="line">  // TODO:6.数据替换</span><br><span class="line">  function replace(frag)&#123;</span><br><span class="line">    Array.from(frag.childNodes).forEach(function (node) &#123;</span><br><span class="line">      let text = node.textContent</span><br><span class="line">      let regExp = /\&#123;\&#123;(.*)\&#125;\&#125;/</span><br><span class="line">      if (node.nodeType === 1 &amp;&amp; regExp.test(text)) &#123;</span><br><span class="line">        let arr = RegExp.$1.trim().split(&apos;.&apos;)</span><br><span class="line">        let val = vm</span><br><span class="line">        arr.forEach(function (k) &#123;</span><br><span class="line">          val = val[k]</span><br><span class="line">        &#125;)</span><br><span class="line">        node.textContent = text.replace(regExp,val).trim()</span><br><span class="line">      &#125;</span><br><span class="line">      if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        replace(node)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  vm.$el.appendChild(fragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Mvvm(options = &#123;&#125;) &#123;</span><br><span class="line">  ....</span><br><span class="line">  // TODO:进行编译</span><br><span class="line">  new Compile(optionns.el,this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-如何实现发布订阅模式"><a href="#问题-如何实现发布订阅模式" class="headerlink" title="问题:如何实现发布订阅模式"></a>问题:如何实现发布订阅模式</h3><p>答:发布订阅主要靠的就是数组关系，订阅就是放入函数，发布就是让数组里的函数执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// TODO:8.发布订阅模式</span><br><span class="line">// TODO:桥梁</span><br><span class="line">function Dep()&#123; // 桥梁</span><br><span class="line">  this.subs = [] // 订阅事件池</span><br><span class="line">&#125;</span><br><span class="line">// TODO:进行订阅的方法(往里面扔函数)</span><br><span class="line">Dep.property.addSub = function (sub) &#123;  //sub就是watcher</span><br><span class="line">  this.subs.push(sub)</span><br><span class="line">&#125;</span><br><span class="line">// TODO:进行发布/通知的方法(让函数的每一项一次执行)</span><br><span class="line">Dep.prototype.notify = function () &#123;</span><br><span class="line">  this.subs.forEach(sub =&gt; sub.update())//绑定的事件,都有一个update属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO:订阅者</span><br><span class="line">function Watcher(fn)&#123; //Watcher是一个类,通过这个类创建的实例都拥有update方法</span><br><span class="line">  this.fn = fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.update = function () &#123; //调用fn()</span><br><span class="line">  this.fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-如何更新视图-当数据改变需要重新刷新视图"><a href="#问题-如何更新视图-当数据改变需要重新刷新视图" class="headerlink" title="问题:如何更新视图-当数据改变需要重新刷新视图"></a>问题:如何更新视图-当数据改变需要重新刷新视图</h3><p>答:现在我们要订阅一个事件，当数据改变需要重新刷新视图，这就需要在replace替换的逻辑里来处理<br>通过new Watcher把数据订阅一下，数据一变就执行改变内容的操作</p><ul><li><p>监听变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// TODO:6.数据替换</span><br><span class="line">  function replace(frag) &#123;</span><br><span class="line">    ...</span><br><span class="line">    node.textContent = text.replace(regExp, val).trim()</span><br><span class="line">    </span><br><span class="line">    // TODO:监听变化</span><br><span class="line">    new Watcher(vm,RegExp.$1,function (newVal) &#123;</span><br><span class="line">        node.textContent = text.replace(regExp,newVal).trim()</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        replace(node)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>重写Watcher构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// TODO:订阅者</span><br><span class="line">function Watcher(vm,exp,fn)&#123; //Watcher是一个类,通过这个类创建的实例都拥有update方法</span><br><span class="line">  this.fn = fn</span><br><span class="line">  this.vm = vm</span><br><span class="line">  this.exp = exp</span><br><span class="line"></span><br><span class="line">  Dep.target = this</span><br><span class="line">  let arr = exp.trim().split(&apos;.&apos;)</span><br><span class="line">  let val = vm</span><br><span class="line">  arr.forEach(function (key) &#123;</span><br><span class="line">    val = val[key]</span><br><span class="line">  &#125;)</span><br><span class="line">  Dep.target = null //  // 上面获取val[key]的时候会调用get方法, 因此使用完毕之后需要把该属性置为null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写数据劫持get和set方法</p><ul><li>解:当获取值的时候就会自动调用get方法，于是我们去找一下数据劫持那里的get方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// TODO:3.观察者</span><br><span class="line">function Observe(obj)&#123;</span><br><span class="line">  // TODO:创建桥梁</span><br><span class="line">  let dep = new Dep()</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    let val = obj[key]</span><br><span class="line">    // TODO:深度劫持</span><br><span class="line">    observe(val)</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(obj,key,&#123;</span><br><span class="line">      enumerable : true,</span><br><span class="line">      get()&#123;</span><br><span class="line">        // TODO:将watcher添加到订阅事件中 [watcher]</span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        return val</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newVal)&#123; // 更改值得时候</span><br><span class="line">        if (newVal === val) return // 设置的值和以前的是一样的东西</span><br><span class="line">        val = newVal // 如果以后在获取值的时候将刚才设置的值丢回去</span><br><span class="line">        // TODO:深度劫持</span><br><span class="line">        observe(newVal)</span><br><span class="line">        // TODO:执行update方法</span><br><span class="line">        dep.notify()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改watcher的update方法</p><ul><li>解:当set修改值的时候执行了dep.notify方法，这个方法是执行watcher的update方法，那么我们再对update进行修改一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.update = function () &#123; //调用fn()</span><br><span class="line">  this.fn()</span><br><span class="line">  // notify的时候值已经更改了</span><br><span class="line">  // 再通过vm, exp来获取新的值</span><br><span class="line">  let arr = this.exp.trim().split(&apos;.&apos;)</span><br><span class="line">  let val = this.vm</span><br><span class="line">  arr.forEach(function(key)&#123;</span><br><span class="line">    val = val[key]</span><br><span class="line">  &#125;)</span><br><span class="line">  this.fn(val) // 将每次拿到的新值去替换&#123;&#123;&#125;&#125;的内容即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="问题-双向数据绑定"><a href="#问题-双向数据绑定" class="headerlink" title="问题:双向数据绑定"></a>问题:双向数据绑定</h3><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;理解Vue响应式原理-只需通过解决以下几个问题即可&quot;&gt;&lt;a href=&quot;#理解Vue响应式原理-只需通过解决以下几个问题即可&quot; class=&quot;headerlink&quot; title=&quot;理解Vue响应式原理,只需通过解决以下几个问题即可&quot;&gt;&lt;/a&gt;理解Vue响应式原理,只需通过解决以下几个问题即可&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如何实现数据劫持?&lt;/li&gt;
&lt;li&gt;如何实现数据代理?(如何对this.xxx的访问代理到this.data.xxx上?)&lt;/li&gt;
&lt;li&gt;如何实现数据编译?&lt;/li&gt;
&lt;li&gt;如何实现发布订阅模式?&lt;/li&gt;
&lt;li&gt;如何实现更新视图?(如何监听数据的读写操作?如何实现数据修改DOM更新?)&lt;/li&gt;
&lt;li&gt;如何实现双向数据绑定?&lt;/li&gt;
&lt;li&gt;如何实现依赖缓存?&lt;/li&gt;
&lt;li&gt;template改变的时候,如何清理依赖项集合?eg:v-if和组件销毁
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>标准网页标签模板及其每个标签的作用</title>
    <link href="http://yoursite.com/2019/10/12/%E6%A0%87%E5%87%86%E7%BD%91%E9%A1%B5%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%E5%8F%8A%E5%85%B6%E6%AF%8F%E4%B8%AA%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2019/10/12/标准网页标签模板及其每个标签的作用/</id>
    <published>2019-10-12T15:06:27.000Z</published>
    <updated>2019-10-13T02:45:49.820Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">    + 声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。  </span><br><span class="line">    + 通过document.compatMode查看模式：</span><br><span class="line">        + BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。</span><br><span class="line">        + CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。        </span><br><span class="line">&lt;html lang=&quot;en/zh-CN&quot;&gt;</span><br><span class="line">    + lang=&quot;en&quot; 向搜索引擎表示该页面是html语言，并且语言为英文网站,并提示浏览器是否进行翻译</span><br><span class="line">    + lang=&quot;zh-CN&quot; 向搜索引擎表示该页面是html语言，并且语言为中文网站</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;/&gt;</span><br><span class="line">    + 声明文档使用的字符编码</span><br><span class="line">&lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;&gt;</span><br><span class="line">    + 移动端布局</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;</span><br><span class="line">    + 告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面或告诉浏览器用chrome内核来渲染</span><br><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;/&gt;</span><br><span class="line">    + 指定双核浏览器默认以何种方式渲染页面</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">    + 标题</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;#[[$description$]]#&quot;/&gt;</span><br><span class="line">    + 描述</span><br><span class="line">&lt;meta name=&quot;keyword&quot; content=&quot;#[[$keyword$]]#&quot;/&gt;</span><br><span class="line">    + 关键字</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端高度塌陷问题</title>
    <link href="http://yoursite.com/2019/10/12/%E5%89%8D%E7%AB%AF%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/10/12/前端高度塌陷问题/</id>
    <published>2019-10-12T07:22:43.000Z</published>
    <updated>2019-10-13T02:36:48.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-产生原因"><a href="#一-产生原因" class="headerlink" title="一.产生原因"></a>一.产生原因</h3><p>  在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。</p><a id="more"></a><h3 id="二-所以在开发中一定要避免出现高度塌陷的问题"><a href="#二-所以在开发中一定要避免出现高度塌陷的问题" class="headerlink" title="二.所以在开发中一定要避免出现高度塌陷的问题,"></a>二.所以在开发中一定要避免出现高度塌陷的问题,</h3><ul><li><h4 id="1-我们可以将父元素的高度写死，以避免塌陷的问题出现，"><a href="#1-我们可以将父元素的高度写死，以避免塌陷的问题出现，" class="headerlink" title="1.我们可以将父元素的高度写死，以避免塌陷的问题出现，"></a>1.我们可以将父元素的高度写死，以避免塌陷的问题出现，</h4><ul><li>但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。</li></ul></li><li><h4 id="2-根据W3C的标准，在页面中元素都一个隐含的属性叫做Block-Formatting-Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。"><a href="#2-根据W3C的标准，在页面中元素都一个隐含的属性叫做Block-Formatting-Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。" class="headerlink" title="2.根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。"></a>2.根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。</h4><ul><li><p>(1)当开启元素的BFC以后，元素将会具有如下的特性：</p><ul><li><strong>父元素的垂直外边距不会和子元素重叠</strong></li><li><strong>开启BFC的元素不会被浮动元素所覆盖</strong></li><li><strong>开启BFC的元素可以包含浮动的子元素</strong></li></ul></li><li><p>(2)如何开启元素的BFC</p><ul><li><p><strong>设置元素浮动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失而且使用这种方式也会导致下边的元素上移，不能解决问题</span><br></pre></td></tr></table></figure></li><li><p><strong>设置元素绝对定位</strong></p></li><li><p><strong>设置元素为inline-block</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以解决问题，但是会导致宽度丢失，不推荐使用这种方式</span><br></pre></td></tr></table></figure></li><li><p><strong>将元素的overflow设置为一个非visible的值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式,</span><br><span class="line">但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题开启方式很多，我们直接使用一种副作用最小的：</span><br><span class="line">   直接将元素的zoom设置为1即可</span><br><span class="line">   zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍</span><br><span class="line">   zoom:1表示不放大元素，但是通过该样式可以开启hasLayout</span><br><span class="line">   zoom这个样式，只在IE中支持，其他浏览器都不支持</span><br></pre></td></tr></table></figure></li><li><p><strong>最终兼容方案</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.clearfix&#123;</span><br><span class="line">    overflow: hidden; </span><br><span class="line">    zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><h4 id="3-通过在高度塌陷的父元素的最后，添加一个空白的div-然后在对其进行清除浮动-但会在页面中添加多余结构"><a href="#3-通过在高度塌陷的父元素的最后，添加一个空白的div-然后在对其进行清除浮动-但会在页面中添加多余结构" class="headerlink" title="3.通过在高度塌陷的父元素的最后，添加一个空白的div,然后在对其进行清除浮动,但会在页面中添加多余结构"></a>3.通过在高度塌陷的父元素的最后，添加一个空白的div,然后在对其进行清除浮动,但会在页面中添加多余结构</h4><ul><li>由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后在对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用,使用这种方式虽然可以解决问题，但是会在页面中添加多余的结构。</li><li><strong>最终方案</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.clearfix&#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="4-通过after伪类在高度塌陷的父元素的最后-添加一个空白的块元素，然后对其清除浮动，不会再页面中添加多余结构"><a href="#4-通过after伪类在高度塌陷的父元素的最后-添加一个空白的块元素，然后对其清除浮动，不会再页面中添加多余结构" class="headerlink" title="4.通过after伪类在高度塌陷的父元素的最后,添加一个空白的块元素，然后对其清除浮动，不会再页面中添加多余结构"></a>4.通过after伪类在高度塌陷的父元素的最后,添加一个空白的块元素，然后对其清除浮动，不会再页面中添加多余结构</h4><ul><li><p>这样做和添加一个div的原理一样，可以达到一个相同的效果，而且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  .clearfix:after&#123;</span><br><span class="line">      // 添加一个内容</span><br><span class="line">      content: &quot;&quot;;</span><br><span class="line">      // 转换为一个块元素</span><br><span class="line">      display: block;</span><br><span class="line">      // 清除两侧的浮动</span><br><span class="line">      clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>在IE6中不支持after伪类,所以在IE6中还需要使用hasLayout来处理</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix&#123;</span><br><span class="line">    zoom:1;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h4 id="5-子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素-使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠"><a href="#5-子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素-使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠" class="headerlink" title="5.子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素,使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠"></a>5.子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素,使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠</h4><ul><li><p><strong>解决父子元素的外边距重叠</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box1:before&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display:table可以将一个元素设置为表格显示</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>解决父元素高度塌陷</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix&#123;</span><br><span class="line">    zoom:1;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>经过修改后的clearfix是一个多功能的既可以解决高度塌陷，又可以确保父元素和子元素的垂直外边距不会重叠</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.clearfix&#123;</span><br><span class="line">    zoom: 1;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: table;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-产生原因&quot;&gt;&lt;a href=&quot;#一-产生原因&quot; class=&quot;headerlink&quot; title=&quot;一.产生原因&quot;&gt;&lt;/a&gt;一.产生原因&lt;/h3&gt;&lt;p&gt;  在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>了解Object.defineProperty()方法</title>
    <link href="http://yoursite.com/2019/10/10/%E4%BA%86%E8%A7%A3Object-defineProperty-%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/10/10/了解Object-defineProperty-方法/</id>
    <published>2019-10-10T15:44:19.000Z</published>
    <updated>2019-10-13T02:38:58.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj,prop,descriptor)"></a>Object.defineProperty(obj,prop,descriptor)</h3><p><strong>1.参数</strong></p><ul><li>obj<br>  要在其上定义属性的对象。</li><li>prop<br>  要定义或修改的属性的名称。</li><li>descriptor<br>  将被定义或修改的属性描述符。</li></ul><p><strong>2.返回值</strong></p><ul><li>被传递给函数的对象obj<a id="more"></a></li></ul><p><strong>3.属性描述符</strong></p><ul><li>configurable // 可删除</li><li>enumerable // 可枚举</li><li>writable // 可赋值</li><li>value</li><li>get // 访问</li><li>set // 修改</li></ul><p><strong>注意:</strong></p><ul><li>value和writable与get和set不能共存</li><li>obj.prop 调用get方法</li><li>obj.prop = ‘xxx’ 调用set方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Object-defineProperty-obj-prop-descriptor&quot;&gt;&lt;a href=&quot;#Object-defineProperty-obj-prop-descriptor&quot; class=&quot;headerlink&quot; title=&quot;Object.defineProperty(obj,prop,descriptor)&quot;&gt;&lt;/a&gt;Object.defineProperty(obj,prop,descriptor)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;obj&lt;br&gt;  要在其上定义属性的对象。&lt;/li&gt;
&lt;li&gt;prop&lt;br&gt;  要定义或修改的属性的名称。&lt;/li&gt;
&lt;li&gt;descriptor&lt;br&gt;  将被定义或修改的属性描述符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.返回值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被传递给函数的对象obj
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>NVM_Node_NPM_CNPM安装</title>
    <link href="http://yoursite.com/2019/10/10/NVM-Node-NPM-CNPM%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/10/10/NVM-Node-NPM-CNPM安装/</id>
    <published>2019-10-10T05:36:11.000Z</published>
    <updated>2019-10-10T12:32:30.867Z</updated>
    
    <content type="html"><![CDATA[<p>NVM-windows安装<br>第一步:下载NVM安装包:<br><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a><br>第二步:创建俩个文件目录,解压安装包到NVM目录中:<br>D:\NVM<br>D:\Node</p><a id="more"></a><p>第三步:进入NVM目录双击 install.cmd 直接回车<br>第四步:修改setting.txt文件复制到D:\NVM目录中<br>root: D:\NVM<br>path: D:\Node<br>arch: 64<br>proxy: none<br>node_mirror: <a href="http://npm.taobao.org/mirrors/node/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/node/</a><br>npm_mirror: <a href="https://npm.taobao.org/mirrors/npm/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/npm/</a><br>第五步:配置环境变量NVM_HOME和NVM_SYMLINK<br>NVM_HOME : D:\NVM<br>NVM_SYMLINK : D:\Node<br>第六步:path中添加变量<br>%NVM_HOME%<br>%NVM_SYMLINK%<br>第七步:查看NVM版本信息<br>nvm -v<br>Node-windows安装<br>第一步:安装Node(为了后续安装全局npm准备)<br>nvm install 6.15.0<br>第二步:使用Node<br>nvm use 6.15.0<br>第三步:在nvm\node_dir下创建node_cache和node_global文件加<br>第四步配置缓冲路径和全局路径(使C:\Users\yi081.npmrc 】文件重新生成)<br>npm config set prefix “D:\NVM\node_dir\node_global”<br>npm config set cache “D:\NVM\node_dir\node_cache”<br>第五步:配置Node环境变量NODE_HOME和NODE_PATH<br>NODE_HOME:D:\Node\node_modules<br>NODE_GLOBAL:D:\NVM\node_dir\node_global (可不配置)<br>NODE_PATH : D:\NVM\node_dir\node_global\node_modules<br>第六步:添加到path中<br>%NODE_HOME%<br>%NODE_GLOBAL% (可不配置)<br>%NODE_PATH%<br>全局安装NPM<br>第一步:下载npm<br>npm install npm@latest -g<br>第二步:配置NPM环境变量<br>NPM_HOME : D:\NVM\node_dir\node_global\npm<br>第三步:添加到path中<br>%NPM_HOME%<br>全局安装CNPM<br>第一步:下载cnpm<br>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>第二步:配置CNPM环境变量(可不配置)<br>CNPM_HOME : D:\NVM\node_dir\node_global\cnpm<br>第三步:添加到path中(可不配置)<br>%NPM_HOME%</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NVM-windows安装&lt;br&gt;第一步:下载NVM安装包:&lt;br&gt;&lt;a href=&quot;https://github.com/coreybutler/nvm-windows/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/coreybutler/nvm-windows/releases&lt;/a&gt;&lt;br&gt;第二步:创建俩个文件目录,解压安装包到NVM目录中:&lt;br&gt;D:\NVM&lt;br&gt;D:\Node&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
