<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱编程-爱挑战-爱学习</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-13T02:46:10.014Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>TWei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue之深入响应式原理</title>
    <link href="http://yoursite.com/2019/10/13/Vue%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/10/13/Vue之深入响应式原理/</id>
    <published>2019-10-13T02:41:02.000Z</published>
    <updated>2019-10-13T02:46:10.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解Vue响应式原理-只需通过解决以下几个问题即可"><a href="#理解Vue响应式原理-只需通过解决以下几个问题即可" class="headerlink" title="理解Vue响应式原理,只需通过解决以下几个问题即可"></a>理解Vue响应式原理,只需通过解决以下几个问题即可</h3><ul><li>如何实现数据劫持?</li><li>如何实现数据代理?(如何对this.xxx的访问代理到this.data.xxx上?)</li><li>如何实现数据编译?</li><li>如何实现发布订阅模式?</li><li>如何实现更新视图?(如何监听数据的读写操作?如何实现数据修改DOM更新?)</li><li>如何实现双向数据绑定?</li><li>如何实现依赖缓存?</li><li>template改变的时候,如何清理依赖项集合?eg:v-if和组件销毁<a id="more"></a></li></ul><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; a.a &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; b &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const vm = new Mvvm(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      a: &#123;</span><br><span class="line">        a: &apos;我是a&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      b: &apos;我是b&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="问题-如何实现数据劫持"><a href="#问题-如何实现数据劫持" class="headerlink" title="问题:如何实现数据劫持"></a>问题:如何实现数据劫持</h3><p>答:通过Object.defineProperty()方法,对data中的属性,在访问或者修改对象的其中某个属性时,通过一段代码拦截这个行为,进行额外的操作或者修改返回结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// TODO:1.定义Mvvm类</span><br><span class="line">function Mvvm(options=&#123;&#125;)&#123;</span><br><span class="line">    // TODO:this代表的是fade实例对象</span><br><span class="line">    // TODO:将所有属性挂载到$options</span><br><span class="line">    this.$options = options</span><br><span class="line">    var data = this._data = this.options.data</span><br><span class="line">    // TODO:调用数据劫持</span><br><span class="line">    observe(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO:3.观察者</span><br><span class="line">function Observe(obj)&#123;</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    let val = obj[key]</span><br><span class="line">    // TODO:深度劫持</span><br><span class="line">    observe(val)</span><br><span class="line">    </span><br><span class="line">    Object.defineProperty(obj,key,&#123;</span><br><span class="line">      enumerable : true,</span><br><span class="line">      get()&#123;</span><br><span class="line">        return val</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newVal)&#123;</span><br><span class="line">        if (newVal === val) return</span><br><span class="line">        val = newVal</span><br><span class="line">        // TODO:深度劫持</span><br><span class="line">        observe(newVal)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO:2.数据劫持-使每个对象都具有get和set方法</span><br><span class="line">function observe(vmData)&#123;</span><br><span class="line">  if (typeof data !== &apos;object&apos;) return</span><br><span class="line">  return new Observe(vmData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-如何实现数据代理-如何对this-xxx的访问代理到this-data-xxx上"><a href="#问题-如何实现数据代理-如何对this-xxx的访问代理到this-data-xxx上" class="headerlink" title="问题:如何实现数据代理-如何对this.xxx的访问代理到this.data.xxx上?"></a>问题:如何实现数据代理-如何对this.xxx的访问代理到this.data.xxx上?</h3><p>答:对于每个data上的属性,都在app上做一个代理,实际操作的是this.data<br>实现的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Mvvm(options = &#123;&#125;) &#123;</span><br><span class="line">  // TODO:this代表的是zhufeng实例对象</span><br><span class="line">  // TODO:将所有属性挂载到$options</span><br><span class="line">  this.$options = options</span><br><span class="line">  //this._data</span><br><span class="line">  var data = this._data = this.$options.data</span><br><span class="line">  observe(data) </span><br><span class="line">  // TODO:4.数据代理</span><br><span class="line">  for (let key in data) &#123;</span><br><span class="line">    Object.defineProperty(this,key,&#123;</span><br><span class="line">      enumerable : true,</span><br><span class="line">      get()&#123;</span><br><span class="line">        return this._data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newVal)&#123;</span><br><span class="line">        this._data[key] = newVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-如何实现数据编译"><a href="#问题-如何实现数据编译" class="headerlink" title="问题:如何实现数据编译"></a>问题:如何实现数据编译</h3><p>答:通过获取vm管理DOM的根节点,让其在内存中完成相关的正则匹配工作,替换DOM中的文本节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// TODO:5数据编译</span><br><span class="line">function Compile(el,vm)&#123;</span><br><span class="line">  vm.$el = document.querySelector(el)</span><br><span class="line">  let fragment = document.createDocumentFragment()</span><br><span class="line">  while (child = vm.$el.firstChild) &#123;</span><br><span class="line">    fragment.appendChild(child)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  replace(fragment)</span><br><span class="line"></span><br><span class="line">  // TODO:6.数据替换</span><br><span class="line">  function replace(frag)&#123;</span><br><span class="line">    Array.from(frag.childNodes).forEach(function (node) &#123;</span><br><span class="line">      let text = node.textContent</span><br><span class="line">      let regExp = /\&#123;\&#123;(.*)\&#125;\&#125;/</span><br><span class="line">      if (node.nodeType === 1 &amp;&amp; regExp.test(text)) &#123;</span><br><span class="line">        let arr = RegExp.$1.trim().split(&apos;.&apos;)</span><br><span class="line">        let val = vm</span><br><span class="line">        arr.forEach(function (k) &#123;</span><br><span class="line">          val = val[k]</span><br><span class="line">        &#125;)</span><br><span class="line">        node.textContent = text.replace(regExp,val).trim()</span><br><span class="line">      &#125;</span><br><span class="line">      if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        replace(node)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  vm.$el.appendChild(fragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Mvvm(options = &#123;&#125;) &#123;</span><br><span class="line">  ....</span><br><span class="line">  // TODO:进行编译</span><br><span class="line">  new Compile(optionns.el,this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-如何实现发布订阅模式"><a href="#问题-如何实现发布订阅模式" class="headerlink" title="问题:如何实现发布订阅模式"></a>问题:如何实现发布订阅模式</h3><p>答:发布订阅主要靠的就是数组关系，订阅就是放入函数，发布就是让数组里的函数执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// TODO:8.发布订阅模式</span><br><span class="line">// TODO:桥梁</span><br><span class="line">function Dep()&#123; // 桥梁</span><br><span class="line">  this.subs = [] // 订阅事件池</span><br><span class="line">&#125;</span><br><span class="line">// TODO:进行订阅的方法(往里面扔函数)</span><br><span class="line">Dep.property.addSub = function (sub) &#123;  //sub就是watcher</span><br><span class="line">  this.subs.push(sub)</span><br><span class="line">&#125;</span><br><span class="line">// TODO:进行发布/通知的方法(让函数的每一项一次执行)</span><br><span class="line">Dep.prototype.notify = function () &#123;</span><br><span class="line">  this.subs.forEach(sub =&gt; sub.update())//绑定的事件,都有一个update属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO:订阅者</span><br><span class="line">function Watcher(fn)&#123; //Watcher是一个类,通过这个类创建的实例都拥有update方法</span><br><span class="line">  this.fn = fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.update = function () &#123; //调用fn()</span><br><span class="line">  this.fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-如何更新视图-当数据改变需要重新刷新视图"><a href="#问题-如何更新视图-当数据改变需要重新刷新视图" class="headerlink" title="问题:如何更新视图-当数据改变需要重新刷新视图"></a>问题:如何更新视图-当数据改变需要重新刷新视图</h3><p>答:现在我们要订阅一个事件，当数据改变需要重新刷新视图，这就需要在replace替换的逻辑里来处理<br>通过new Watcher把数据订阅一下，数据一变就执行改变内容的操作</p><ul><li><p>监听变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// TODO:6.数据替换</span><br><span class="line">  function replace(frag) &#123;</span><br><span class="line">    ...</span><br><span class="line">    node.textContent = text.replace(regExp, val).trim()</span><br><span class="line">    </span><br><span class="line">    // TODO:监听变化</span><br><span class="line">    new Watcher(vm,RegExp.$1,function (newVal) &#123;</span><br><span class="line">        node.textContent = text.replace(regExp,newVal).trim()</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        replace(node)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>重写Watcher构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// TODO:订阅者</span><br><span class="line">function Watcher(vm,exp,fn)&#123; //Watcher是一个类,通过这个类创建的实例都拥有update方法</span><br><span class="line">  this.fn = fn</span><br><span class="line">  this.vm = vm</span><br><span class="line">  this.exp = exp</span><br><span class="line"></span><br><span class="line">  Dep.target = this</span><br><span class="line">  let arr = exp.trim().split(&apos;.&apos;)</span><br><span class="line">  let val = vm</span><br><span class="line">  arr.forEach(function (key) &#123;</span><br><span class="line">    val = val[key]</span><br><span class="line">  &#125;)</span><br><span class="line">  Dep.target = null //  // 上面获取val[key]的时候会调用get方法, 因此使用完毕之后需要把该属性置为null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写数据劫持get和set方法</p><ul><li>解:当获取值的时候就会自动调用get方法，于是我们去找一下数据劫持那里的get方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// TODO:3.观察者</span><br><span class="line">function Observe(obj)&#123;</span><br><span class="line">  // TODO:创建桥梁</span><br><span class="line">  let dep = new Dep()</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    let val = obj[key]</span><br><span class="line">    // TODO:深度劫持</span><br><span class="line">    observe(val)</span><br><span class="line"></span><br><span class="line">    Object.defineProperty(obj,key,&#123;</span><br><span class="line">      enumerable : true,</span><br><span class="line">      get()&#123;</span><br><span class="line">        // TODO:将watcher添加到订阅事件中 [watcher]</span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        return val</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newVal)&#123; // 更改值得时候</span><br><span class="line">        if (newVal === val) return // 设置的值和以前的是一样的东西</span><br><span class="line">        val = newVal // 如果以后在获取值的时候将刚才设置的值丢回去</span><br><span class="line">        // TODO:深度劫持</span><br><span class="line">        observe(newVal)</span><br><span class="line">        // TODO:执行update方法</span><br><span class="line">        dep.notify()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修改watcher的update方法</p><ul><li>解:当set修改值的时候执行了dep.notify方法，这个方法是执行watcher的update方法，那么我们再对update进行修改一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.update = function () &#123; //调用fn()</span><br><span class="line">  this.fn()</span><br><span class="line">  // notify的时候值已经更改了</span><br><span class="line">  // 再通过vm, exp来获取新的值</span><br><span class="line">  let arr = this.exp.trim().split(&apos;.&apos;)</span><br><span class="line">  let val = this.vm</span><br><span class="line">  arr.forEach(function(key)&#123;</span><br><span class="line">    val = val[key]</span><br><span class="line">  &#125;)</span><br><span class="line">  this.fn(val) // 将每次拿到的新值去替换&#123;&#123;&#125;&#125;的内容即可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="问题-双向数据绑定"><a href="#问题-双向数据绑定" class="headerlink" title="问题:双向数据绑定"></a>问题:双向数据绑定</h3><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;理解Vue响应式原理-只需通过解决以下几个问题即可&quot;&gt;&lt;a href=&quot;#理解Vue响应式原理-只需通过解决以下几个问题即可&quot; class=&quot;headerlink&quot; title=&quot;理解Vue响应式原理,只需通过解决以下几个问题即可&quot;&gt;&lt;/a&gt;理解Vue响应式原理,只需通过解决以下几个问题即可&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如何实现数据劫持?&lt;/li&gt;
&lt;li&gt;如何实现数据代理?(如何对this.xxx的访问代理到this.data.xxx上?)&lt;/li&gt;
&lt;li&gt;如何实现数据编译?&lt;/li&gt;
&lt;li&gt;如何实现发布订阅模式?&lt;/li&gt;
&lt;li&gt;如何实现更新视图?(如何监听数据的读写操作?如何实现数据修改DOM更新?)&lt;/li&gt;
&lt;li&gt;如何实现双向数据绑定?&lt;/li&gt;
&lt;li&gt;如何实现依赖缓存?&lt;/li&gt;
&lt;li&gt;template改变的时候,如何清理依赖项集合?eg:v-if和组件销毁
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>标准网页标签模板及其每个标签的作用</title>
    <link href="http://yoursite.com/2019/10/12/%E6%A0%87%E5%87%86%E7%BD%91%E9%A1%B5%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%E5%8F%8A%E5%85%B6%E6%AF%8F%E4%B8%AA%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2019/10/12/标准网页标签模板及其每个标签的作用/</id>
    <published>2019-10-12T15:06:27.000Z</published>
    <updated>2019-10-13T02:45:49.820Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">    + 声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。  </span><br><span class="line">    + 通过document.compatMode查看模式：</span><br><span class="line">        + BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。</span><br><span class="line">        + CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。        </span><br><span class="line">&lt;html lang=&quot;en/zh-CN&quot;&gt;</span><br><span class="line">    + lang=&quot;en&quot; 向搜索引擎表示该页面是html语言，并且语言为英文网站,并提示浏览器是否进行翻译</span><br><span class="line">    + lang=&quot;zh-CN&quot; 向搜索引擎表示该页面是html语言，并且语言为中文网站</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;/&gt;</span><br><span class="line">    + 声明文档使用的字符编码</span><br><span class="line">&lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;&gt;</span><br><span class="line">    + 移动端布局</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;</span><br><span class="line">    + 告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面或告诉浏览器用chrome内核来渲染</span><br><span class="line">&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;/&gt;</span><br><span class="line">    + 指定双核浏览器默认以何种方式渲染页面</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">    + 标题</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;#[[$description$]]#&quot;/&gt;</span><br><span class="line">    + 描述</span><br><span class="line">&lt;meta name=&quot;keyword&quot; content=&quot;#[[$keyword$]]#&quot;/&gt;</span><br><span class="line">    + 关键字</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端高度塌陷问题</title>
    <link href="http://yoursite.com/2019/10/12/%E5%89%8D%E7%AB%AF%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/10/12/前端高度塌陷问题/</id>
    <published>2019-10-12T07:22:43.000Z</published>
    <updated>2019-10-13T02:36:48.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-产生原因"><a href="#一-产生原因" class="headerlink" title="一.产生原因"></a>一.产生原因</h3><p>  在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。</p><a id="more"></a><h3 id="二-所以在开发中一定要避免出现高度塌陷的问题"><a href="#二-所以在开发中一定要避免出现高度塌陷的问题" class="headerlink" title="二.所以在开发中一定要避免出现高度塌陷的问题,"></a>二.所以在开发中一定要避免出现高度塌陷的问题,</h3><ul><li><h4 id="1-我们可以将父元素的高度写死，以避免塌陷的问题出现，"><a href="#1-我们可以将父元素的高度写死，以避免塌陷的问题出现，" class="headerlink" title="1.我们可以将父元素的高度写死，以避免塌陷的问题出现，"></a>1.我们可以将父元素的高度写死，以避免塌陷的问题出现，</h4><ul><li>但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。</li></ul></li><li><h4 id="2-根据W3C的标准，在页面中元素都一个隐含的属性叫做Block-Formatting-Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。"><a href="#2-根据W3C的标准，在页面中元素都一个隐含的属性叫做Block-Formatting-Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。" class="headerlink" title="2.根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。"></a>2.根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context简称BFC，该属性可以设置打开或者关闭，默认是关闭的。</h4><ul><li><p>(1)当开启元素的BFC以后，元素将会具有如下的特性：</p><ul><li><strong>父元素的垂直外边距不会和子元素重叠</strong></li><li><strong>开启BFC的元素不会被浮动元素所覆盖</strong></li><li><strong>开启BFC的元素可以包含浮动的子元素</strong></li></ul></li><li><p>(2)如何开启元素的BFC</p><ul><li><p><strong>设置元素浮动</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失而且使用这种方式也会导致下边的元素上移，不能解决问题</span><br></pre></td></tr></table></figure></li><li><p><strong>设置元素绝对定位</strong></p></li><li><p><strong>设置元素为inline-block</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以解决问题，但是会导致宽度丢失，不推荐使用这种方式</span><br></pre></td></tr></table></figure></li><li><p><strong>将元素的overflow设置为一个非visible的值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式,</span><br><span class="line">但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题开启方式很多，我们直接使用一种副作用最小的：</span><br><span class="line">   直接将元素的zoom设置为1即可</span><br><span class="line">   zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍</span><br><span class="line">   zoom:1表示不放大元素，但是通过该样式可以开启hasLayout</span><br><span class="line">   zoom这个样式，只在IE中支持，其他浏览器都不支持</span><br></pre></td></tr></table></figure></li><li><p><strong>最终兼容方案</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.clearfix&#123;</span><br><span class="line">    overflow: hidden; </span><br><span class="line">    zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><h4 id="3-通过在高度塌陷的父元素的最后，添加一个空白的div-然后在对其进行清除浮动-但会在页面中添加多余结构"><a href="#3-通过在高度塌陷的父元素的最后，添加一个空白的div-然后在对其进行清除浮动-但会在页面中添加多余结构" class="headerlink" title="3.通过在高度塌陷的父元素的最后，添加一个空白的div,然后在对其进行清除浮动,但会在页面中添加多余结构"></a>3.通过在高度塌陷的父元素的最后，添加一个空白的div,然后在对其进行清除浮动,但会在页面中添加多余结构</h4><ul><li>由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后在对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用,使用这种方式虽然可以解决问题，但是会在页面中添加多余的结构。</li><li><strong>最终方案</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.clearfix&#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="4-通过after伪类在高度塌陷的父元素的最后-添加一个空白的块元素，然后对其清除浮动，不会再页面中添加多余结构"><a href="#4-通过after伪类在高度塌陷的父元素的最后-添加一个空白的块元素，然后对其清除浮动，不会再页面中添加多余结构" class="headerlink" title="4.通过after伪类在高度塌陷的父元素的最后,添加一个空白的块元素，然后对其清除浮动，不会再页面中添加多余结构"></a>4.通过after伪类在高度塌陷的父元素的最后,添加一个空白的块元素，然后对其清除浮动，不会再页面中添加多余结构</h4><ul><li><p>这样做和添加一个div的原理一样，可以达到一个相同的效果，而且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  .clearfix:after&#123;</span><br><span class="line">      // 添加一个内容</span><br><span class="line">      content: &quot;&quot;;</span><br><span class="line">      // 转换为一个块元素</span><br><span class="line">      display: block;</span><br><span class="line">      // 清除两侧的浮动</span><br><span class="line">      clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>在IE6中不支持after伪类,所以在IE6中还需要使用hasLayout来处理</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix&#123;</span><br><span class="line">    zoom:1;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h4 id="5-子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素-使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠"><a href="#5-子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素-使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠" class="headerlink" title="5.子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素,使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠"></a>5.子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素,使用空的table标签可以隔离父子元素的外边距，阻止外边距的重叠</h4><ul><li><p><strong>解决父子元素的外边距重叠</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box1:before&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display:table可以将一个元素设置为表格显示</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>解决父元素高度塌陷</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix&#123;</span><br><span class="line">    zoom:1;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>经过修改后的clearfix是一个多功能的既可以解决高度塌陷，又可以确保父元素和子元素的垂直外边距不会重叠</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.clearfix&#123;</span><br><span class="line">    zoom: 1;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: table;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-产生原因&quot;&gt;&lt;a href=&quot;#一-产生原因&quot; class=&quot;headerlink&quot; title=&quot;一.产生原因&quot;&gt;&lt;/a&gt;一.产生原因&lt;/h3&gt;&lt;p&gt;  在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>了解Object.defineProperty()方法</title>
    <link href="http://yoursite.com/2019/10/10/%E4%BA%86%E8%A7%A3Object-defineProperty-%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/10/10/了解Object-defineProperty-方法/</id>
    <published>2019-10-10T15:44:19.000Z</published>
    <updated>2019-10-13T02:38:58.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object-defineProperty-obj-prop-descriptor"><a href="#Object-defineProperty-obj-prop-descriptor" class="headerlink" title="Object.defineProperty(obj,prop,descriptor)"></a>Object.defineProperty(obj,prop,descriptor)</h3><p><strong>1.参数</strong></p><ul><li>obj<br>  要在其上定义属性的对象。</li><li>prop<br>  要定义或修改的属性的名称。</li><li>descriptor<br>  将被定义或修改的属性描述符。</li></ul><p><strong>2.返回值</strong></p><ul><li>被传递给函数的对象obj<a id="more"></a></li></ul><p><strong>3.属性描述符</strong></p><ul><li>configurable // 可删除</li><li>enumerable // 可枚举</li><li>writable // 可赋值</li><li>value</li><li>get // 访问</li><li>set // 修改</li></ul><p><strong>注意:</strong></p><ul><li>value和writable与get和set不能共存</li><li>obj.prop 调用get方法</li><li>obj.prop = ‘xxx’ 调用set方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Object-defineProperty-obj-prop-descriptor&quot;&gt;&lt;a href=&quot;#Object-defineProperty-obj-prop-descriptor&quot; class=&quot;headerlink&quot; title=&quot;Object.defineProperty(obj,prop,descriptor)&quot;&gt;&lt;/a&gt;Object.defineProperty(obj,prop,descriptor)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;obj&lt;br&gt;  要在其上定义属性的对象。&lt;/li&gt;
&lt;li&gt;prop&lt;br&gt;  要定义或修改的属性的名称。&lt;/li&gt;
&lt;li&gt;descriptor&lt;br&gt;  将被定义或修改的属性描述符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.返回值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被传递给函数的对象obj
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>NVM_Node_NPM_CNPM安装</title>
    <link href="http://yoursite.com/2019/10/10/NVM-Node-NPM-CNPM%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/10/10/NVM-Node-NPM-CNPM安装/</id>
    <published>2019-10-10T05:36:11.000Z</published>
    <updated>2019-10-10T12:32:30.867Z</updated>
    
    <content type="html"><![CDATA[<p>NVM-windows安装<br>第一步:下载NVM安装包:<br><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a><br>第二步:创建俩个文件目录,解压安装包到NVM目录中:<br>D:\NVM<br>D:\Node</p><a id="more"></a><p>第三步:进入NVM目录双击 install.cmd 直接回车<br>第四步:修改setting.txt文件复制到D:\NVM目录中<br>root: D:\NVM<br>path: D:\Node<br>arch: 64<br>proxy: none<br>node_mirror: <a href="http://npm.taobao.org/mirrors/node/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/node/</a><br>npm_mirror: <a href="https://npm.taobao.org/mirrors/npm/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/npm/</a><br>第五步:配置环境变量NVM_HOME和NVM_SYMLINK<br>NVM_HOME : D:\NVM<br>NVM_SYMLINK : D:\Node<br>第六步:path中添加变量<br>%NVM_HOME%<br>%NVM_SYMLINK%<br>第七步:查看NVM版本信息<br>nvm -v<br>Node-windows安装<br>第一步:安装Node(为了后续安装全局npm准备)<br>nvm install 6.15.0<br>第二步:使用Node<br>nvm use 6.15.0<br>第三步:在nvm\node_dir下创建node_cache和node_global文件加<br>第四步配置缓冲路径和全局路径(使C:\Users\yi081.npmrc 】文件重新生成)<br>npm config set prefix “D:\NVM\node_dir\node_global”<br>npm config set cache “D:\NVM\node_dir\node_cache”<br>第五步:配置Node环境变量NODE_HOME和NODE_PATH<br>NODE_HOME:D:\Node\node_modules<br>NODE_GLOBAL:D:\NVM\node_dir\node_global (可不配置)<br>NODE_PATH : D:\NVM\node_dir\node_global\node_modules<br>第六步:添加到path中<br>%NODE_HOME%<br>%NODE_GLOBAL% (可不配置)<br>%NODE_PATH%<br>全局安装NPM<br>第一步:下载npm<br>npm install npm@latest -g<br>第二步:配置NPM环境变量<br>NPM_HOME : D:\NVM\node_dir\node_global\npm<br>第三步:添加到path中<br>%NPM_HOME%<br>全局安装CNPM<br>第一步:下载cnpm<br>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>第二步:配置CNPM环境变量(可不配置)<br>CNPM_HOME : D:\NVM\node_dir\node_global\cnpm<br>第三步:添加到path中(可不配置)<br>%NPM_HOME%</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NVM-windows安装&lt;br&gt;第一步:下载NVM安装包:&lt;br&gt;&lt;a href=&quot;https://github.com/coreybutler/nvm-windows/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/coreybutler/nvm-windows/releases&lt;/a&gt;&lt;br&gt;第二步:创建俩个文件目录,解压安装包到NVM目录中:&lt;br&gt;D:\NVM&lt;br&gt;D:\Node&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
